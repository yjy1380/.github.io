<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Python编程惯例 | yjy&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="“main“需要说明的是，如果我们导入的模块除了定义函数之外还有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是”main“。 1234567891011121314151617">
<meta property="og:type" content="article">
<meta property="og:title" content="Python编程惯例">
<meta property="og:url" content="http://yjy1380.github.io/1989/06/05/python%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="yjy&#39;s blog">
<meta property="og:description" content="“main“需要说明的是，如果我们导入的模块除了定义函数之外还有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是”main“。 1234567891011121314151617">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="1989-06-04T15:00:00.000Z">
<meta property="article:modified_time" content="2024-03-14T07:12:10.052Z">
<meta property="article:author" content="Junyi Yang">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="PEP8">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="yjy's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">yjy&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">希望能多用英语</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yjy1380.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-python复习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1989/06/05/python%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="1989-06-04T15:00:00.000Z" itemprop="datePublished">1989-06-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Python编程惯例
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="“main“"><a href="#“main“" class="headerlink" title="“main“"></a>“<strong>main</strong>“</h2><p>需要说明的是，如果我们导入的模块除了定义函数之外还有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为<strong>只有直接执行的模块的名字才是”<strong>main</strong>“。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##module3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span></span><br><span class="line"><span class="comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;call foo()&#x27;</span>)</span><br><span class="line">    foo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;call bar()&#x27;</span>)</span><br><span class="line">    bar()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">####################</span></span><br><span class="line"><span class="keyword">import</span> module3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</span></span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在参数名前面的*表示args是一个可变参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> args:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 在调用add函数时可以传入0个或多个参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add())</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure>







<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a><strong>条件表达式</strong></h2><p>(x, y) &#x3D; (y, x) if x &gt; y else (x, y)。<strong>条件表达式</strong>，也称为三元表达式  意为：</p>
<p>如果 x &gt; y那么 <code>(y, x)</code> 就会被赋值给 <code>(x, y)</code>，否则  <code>(x, y)</code> 就会被赋值给 <code>(x, y)</code></p>
<p>可以在字符串中使用<code>\</code>（反斜杠）来表示转义，也就是说<code>\</code>后面的字符不再是它原来的意义，例如：<code>\n</code>不是代表反斜杠和字符n，而是表示换行；而<code>\t</code>也不是代表反斜杠和字符t，而是表示制表符。所以如果想在字符串中表示<code>&#39;</code>要写成<code>\&#39;</code>，同理想表示<code>\</code>要写成<code>\\</code>。如果不希望字符串中的<code>\</code>表示转义，我们可以通过在字符串的最前面加上字母<code>r</code>来加以说明   s1 &#x3D; r’&#39;hello, world!&#39;’</p>
<p>Python为字符串类型提供了非常丰富的运算符，我们可以使用<code>+</code>运算符来实现字符串的拼接，可以使用<code>*</code>运算符来重复一个字符串的内容，可以使用<code>in</code>和<code>not in</code>来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用<code>[]</code>和<code>[:]</code>运算符从字符串取出某个字符或某些字符（切片运算）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span><br><span class="line"></span><br><span class="line">在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头</span><br></pre></td></tr></table></figure>



<h2 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h2><p>是 Python 中的一个关键字，用于创建匿名函数。匿名函数是指在运行时临时创建的、不需要使用 def 关键字定义的函数。lambda 函数通常用于需要一个简单函数的地方，而不想正式定义一个函数。</p>
<h2 id="getter（访问器）和setter（修改器）"><a href="#getter（访问器）和setter（修改器）" class="headerlink" title="getter（访问器）和setter（修改器）"></a>getter（访问器）和setter（修改器）</h2><p>之前我们讨论过Python中属性和方法<strong>访问权限</strong>的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，</p>
<p><strong>Getter（访问器）</strong>： Getter是一个方法，用于获取（访问）类的属性的值。它允许在获取属性值之前执行额外的逻辑或验证。在Python中，通常使用**@property装饰器**将一个方法标记为getter方法。当我们尝试访问属性时，实际上是调用了getter方法，而不是直接访问属性。</p>
<p><strong>Setter（修改器）</strong>： Setter是一个方法，用于修改类的属性的值。它允许在设置属性值之前执行额外的逻辑或验证。在Python中，通常使用**@property.setter装饰器**将一个方法标记为setter方法。当我们尝试设置属性时，实际上是调用了setter方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._my_attribute = <span class="number">0</span>  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_attribute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 可以在这里添加逻辑或验证</span></span><br><span class="line">        <span class="keyword">return</span> self._my_attribute</span><br><span class="line">    </span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.my_attribute)  <span class="comment"># 调用getter方法获取属性值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._my_attribute = <span class="number">0</span>  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_attribute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._my_attribute</span><br><span class="line"></span><br><span class="line"><span class="meta">    @my_attribute.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_attribute</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 可以在这里添加逻辑或验证</span></span><br><span class="line">        self._my_attribute = value</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.my_attribute = <span class="number">10</span>  <span class="comment"># 调用setter方法设置属性值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="slots-变量绑定属性"><a href="#slots-变量绑定属性" class="headerlink" title="__slots__变量绑定属性"></a>__slots__变量绑定属性</h2><p>Python是一门<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80">动态语言</a>。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="comment"># 限定Person对象只能绑定_name, _age和_gender属性</span></span><br><span class="line">__slots__ = (<span class="string">&#x27;_name&#x27;</span>, <span class="string">&#x27;_age&#x27;</span>, <span class="string">&#x27;_gender&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">    self._name = name</span><br><span class="line">    self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">@age.setter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self, age</span>):</span><br><span class="line">    self._age = age</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    person = Person(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">22</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person._gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    <span class="comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;_is_gay&#x27;</span></span><br><span class="line">    <span class="comment"># person._is_gay = True</span></span><br></pre></td></tr></table></figure>





<h2 id="静态方法和类方法-staticmethod-cls"><a href="#静态方法和类方法-staticmethod-cls" class="headerlink" title="静态方法和类方法 @staticmethod cls"></a>静态方法和类方法 @staticmethod cls</h2><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">    self._a = a</span><br><span class="line">    self._b = b</span><br><span class="line">    self._c = c</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self._a + self._b + self._c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">    half = self.perimeter() / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(half * (half - self._a) *</span><br><span class="line">                (half - self._b) * (half - self._c))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">    <span class="comment"># 静态方法和类方法都是通过给类发消息来调用的</span></span><br><span class="line">    <span class="keyword">if</span> Triangle.is_valid(a, b, c):</span><br><span class="line">        t = Triangle(a, b, c)</span><br><span class="line">        <span class="built_in">print</span>(t.perimeter())</span><br><span class="line">        <span class="comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span></span><br><span class="line">        <span class="comment"># print(Triangle.perimeter(t))</span></span><br><span class="line">        <span class="built_in">print</span>(t.area())</span><br><span class="line">        <span class="comment"># print(Triangle.area(t))</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法构成三角形.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><strong><code>@staticmethod</code></strong> 是一个 Python 装饰器，用于定义<strong>静态方法</strong>。静态方法是属于类的方法，但与类的实例无关，因此它们不需要访问类的实例变量。静态方法通常用于<strong>与类相关的功能</strong>，静态方法在类的定义中使用 <code>@staticmethod</code> 装饰器来标识，并且不需要 <code>self</code> 或 <code>cls</code> 参数（虽然它们可以接受任意数量的参数）。在静态方法中，通常不需要引用类或实例变量，因为它们与类或实例无关。</p>
<p>和静态方法比较类似，Python还可以在类中定义<strong>类方法</strong>，类方法的第一个参数约定名为<strong>cls</strong>，它代表的是<strong>当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象）</strong>，通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象</p>
<h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。</p>
<ul>
<li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li>
<li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li>
<li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li>
</ul>
<h2 id="基于tkinter模块的GUI"><a href="#基于tkinter模块的GUI" class="headerlink" title="基于tkinter模块的GUI"></a>基于tkinter模块的GUI</h2><p>GUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。</p>
<p>基本上使用tkinter来开发GUI应用需要以下5个步骤：</p>
<ol>
<li><p>导入tkinter模块中我们需要的东西。</p>
</li>
<li><p>创建一个顶层窗口对象并用它来承载整个GUI应用。</p>
</li>
<li><p>在顶层窗口对象上添加GUI组件。</p>
</li>
<li><p>通过代码将这些GUI组件的功能组织起来。</p>
</li>
<li><p>进入主事件循环(main loop)。</p>
<p> 需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。</p>
</li>
</ol>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。</p>
<p><strong>json模块</strong>主要有四个比较重要的函数，分别是：</p>
<ul>
<li><code>dump</code> - 将Python对象按照JSON格式序列化到文件中</li>
<li><code>dumps</code> - 将Python对象处理成JSON格式的字符串</li>
<li><code>load</code> - 将文件中的JSON数据反序列化成对象</li>
<li><code>loads</code> - 将字符串的内容反序列化成Python对象</li>
</ul>
<p>这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/">维基百科</a>上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。</p>
<p>目前绝大多数网络数据服务（或称之为网络API）都是基于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP协议</a>提供JSON格式的数据</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><a target="_blank" rel="noopener" href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a> Python提供了re模块来支持正则表达式相关操作</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程</strong>就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。</p>
<p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。</p>
<p>接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process  通过Process类创建了进程对象</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_task</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(string, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">&#x27;Ping&#x27;</span>, )).start()</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">&#x27;Pong&#x27;</span>, )).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和<a target="_blank" rel="noopener" href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下</p>
<p>在上面的代码中，我们通过<code>Process</code>类创建了<strong>进程</strong>对象，通过<code>target</code>参数我们传入一个函数来表示进程启动后要执行的代码，后面的<code>args</code>是一个元组，它代表了传递给函数的参数。<code>Process</code>对象的<code>start</code>方法用来启动进程，而<code>join</code>方法表示等待进程执行结束。</p>
<h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><p>在Python早期的版本中就引入了<strong>thread模块</strong>（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。</p>
<p>在 Python 中，<code>Thread</code> 类是 <code>threading</code> 模块中的一个重要类，用于创建和管理<strong>线程</strong>。<code>Thread</code> 类提供了一种方便的方式来实现多线程编程，使得程序能够同时执行多个任务，从而提高程序的并发性和性能。</p>
<p><code>Thread</code> 类的主要功能包括：</p>
<ol>
<li><p><strong>创建线程</strong>：通过实例化 <code>Thread</code> 类来创建线程。可以将要执行的函数或方法作为参数传递给 <code>Thread</code> 对象的构造函数，也可以通过继承 <code>Thread</code> 类并重写 <code>run</code> 方法来定义线程执行的逻辑。</p>
</li>
<li><p><strong>启动线程</strong>：通过调用 <code>Thread</code> 对象的 <code>start()</code> 方法来启动线程。一旦线程被启动，它将开始执行 <code>run</code> 方法中定义的逻辑。</p>
</li>
<li><p><strong>等待线程结束</strong>：可以调用 <code>Thread</code> 对象的 <code>join()</code> 方法来等待线程执行完毕。调用 <code>join()</code> 方法会阻塞当前线程，直到被调用的线程执行完毕。</p>
</li>
<li><p><strong>守护线程</strong>：可以通过设置 <code>daemon</code> 参数将线程设置为守护线程。守护线程会在主程序退出时自动结束，而不会阻止主程序的退出。</p>
</li>
<li><p><strong>线程间通信</strong>：线程之间可以通过共享的变量或队列等机制进行通信。但是要注意线程安全，避免因并发访问而引发的数据竞争和死锁等问题。</p>
</li>
</ol>
<p>总之，<code>Thread</code> 类提供了一种方便的方式来实现<strong>多线程编程</strong>，使得程序能够更高效地利用多核 CPU 和并发执行任务。</p>
<p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep  <span class="comment"># 导入 sleep 函数，用于模拟时间延迟</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread  <span class="comment"># 导入 Thread 类，用于多线程编程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 定义 Account 类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._balance = <span class="number">0</span>  <span class="comment"># 初始化账户余额为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="comment"># 定义 deposit 方法，用于存款</span></span><br><span class="line">        new_balance = self._balance + money  <span class="comment"># 计算存款后的余额</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)  <span class="comment"># 模拟受理存款业务需要0.01秒的时间</span></span><br><span class="line">        self._balance = new_balance  <span class="comment"># 修改账户余额</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义 balance 属性，用于获取账户余额</span></span><br><span class="line">        <span class="keyword">return</span> self._balance  <span class="comment"># 返回账户余额</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddMoneyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="comment"># 定义 AddMoneyThread 类，继承自 Thread 类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account, money</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类的构造方法</span></span><br><span class="line">        self._account = account  <span class="comment"># 保存账户对象</span></span><br><span class="line">        self._money = money  <span class="comment"># 保存存款金额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义 run 方法，用于线程执行的逻辑</span></span><br><span class="line">        self._account.deposit(self._money)  <span class="comment"># 调用账户对象的 deposit 方法进行存款</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 主函数</span></span><br><span class="line"></span><br><span class="line">    account = Account()  <span class="comment"># 创建账户对象</span></span><br><span class="line">    threads = []  <span class="comment"># 创建一个线程列表，用于保存所有的存款线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建100个存款的线程向同一个账户中存钱</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)  <span class="comment"># 创建存款线程，存款金额为1</span></span><br><span class="line">        threads.append(t)  <span class="comment"># 将线程添加到线程列表中</span></span><br><span class="line">        t.start()  <span class="comment"># 启动线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有存款的线程都执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出账户余额</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;账户余额为: ￥%d元&#x27;</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()  <span class="comment"># 调用主函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到<code>new_balance = self._balance + money</code>这行代码，多个线程得到的账户余额都是初始状态下的<code>0</code>，所以都是<code>0</code>上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line">        self._lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="comment"># 先获取锁才能执行后续的代码</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_balance = self._balance + money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self._balance = new_balance</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 在finally中执行释放锁的操作保证正常异常锁都能释放</span></span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddMoneyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account, money</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;账户余额为: ￥%d元&#x27;</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p>
<p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I&#x2F;O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C&#x2F;C++代码的机制。</p>
<p>除了计算密集型任务，其他的涉及到网络、存储介质I&#x2F;O的任务都可以视为I&#x2F;O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I&#x2F;O操作完成（因为I&#x2F;O的速度远远低于CPU和内存的速度）。对于I&#x2F;O密集型任务，如果启动多任务，就可以减少I&#x2F;O等待时间从而让CPU高效率的运转。有一大类的任务都属于I&#x2F;O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。</p>
<h3 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I&#x2F;O"></a>单线程+异步I&#x2F;O</h3><p>现代操作系统对I&#x2F;O操作的改进中最为重要的就是支持异步I&#x2F;O。如果充分利用操作系统提供的异步I&#x2F;O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I&#x2F;O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。</p>
<p>在Python语言中，单线程+异步I&#x2F;O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。</p>
<h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><p>requests是一个基于HTTP协议来使用网络的第三库，其<a target="_blank" rel="noopener" href="http://cn.python-requests.org/zh_CN/latest/">官方网站</a>有这样的一句介绍它的话：“Requests是唯一的一个<strong>非转基因</strong>的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。</p>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p><strong>套接字</strong>这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C语言</a>写成的应用程序开发库，主要用于实现进程间通信和网络编程</p>
<p>所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。</p>
<p>这里的端口并不是物理设备而是<strong>对IP地址的扩展</strong>，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。</p>
<h2 id="Socket-通信端点"><a href="#Socket-通信端点" class="headerlink" title="Socket 通信端点"></a>Socket 通信端点</h2><p>Socket是计算机网络编程中的一个抽象概念，它代表了两个网络节点之间的通信端点。通过Socket，程序可以在网络上进行数据的发送和接收。在Python中，可以使用内置的<code>socket</code>模块来实现Socket编程。</p>
<p>以下是Socket编程的基本步骤：</p>
<ol>
<li><strong>创建Socket对象</strong>：首先，需要创建一个Socket对象，用于表示一个网络连接。可以通过<code>socket.socket()</code>函数来创建Socket对象，该函数接受两个参数：地址族（通常是<code>socket.AF_INET</code>表示IPv4）和套接字类型（如<code>socket.SOCK_STREAM</code>表示TCP套接字，<code>socket.SOCK_DGRAM</code>表示UDP套接字）。</li>
<li><strong>连接到远程主机（对于客户端）</strong>：如果是客户端程序，需要调用<code>connect()</code>方法连接到远程主机的Socket。</li>
<li><strong>绑定和监听（对于服务器端）</strong>：如果是服务器端程序，需要将Socket绑定到一个特定的地址和端口，然后调用<code>listen()</code>方法开始监听连接请求。</li>
<li><strong>接受连接（对于服务器端）</strong>：当有客户端连接请求到达时，服务器端调用<code>accept()</code>方法接受连接，并返回一个新的Socket对象，用于与客户端通信。</li>
<li><strong>发送和接收数据</strong>：通过Socket对象的<code>send()</code>和<code>recv()</code>方法来发送和接收数据。对于TCP套接字，数据是可靠的，会按照顺序传输；对于UDP套接字，数据是不可靠的，可能会丢失或乱序。</li>
<li><strong>关闭连接</strong>：当通信结束时，需要调用Socket对象的<code>close()</code>方法关闭连接。</li>
</ol>
<h2 id="生成式（推导式）的用法"><a href="#生成式（推导式）的用法" class="headerlink" title="生成式（推导式）的用法"></a><strong>生成式</strong>（推导式）的用法</h2><p>Python 中有三种类型的生成式：列表推导式、集合推导式和字典推导式</p>
<p>列表推导式用于创建列表。语法形式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition]</span><br><span class="line"></span><br><span class="line"><span class="comment">#其中，expression 是一个表达式，item 是迭代对象中的元素，iterable 是一个可迭代对象#（如列表、元组、集合、字典等），condition 是一个可选的条件表达式，用于筛选元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含1到10的平方的列表</span></span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br></pre></td></tr></table></figure>

<p>集合推导式用于创建集合。语法形式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition&#125;</span><br><span class="line"><span class="comment"># 创建一个包含1到10的平方的集合</span></span><br><span class="line">squares_set = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(squares_set)</span><br></pre></td></tr></table></figure>

<p>字典推导式用于创建字典。语法形式为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">&#x27;AAPL&#x27;</span>: <span class="number">191.88</span>,</span><br><span class="line">    <span class="string">&#x27;GOOG&#x27;</span>: <span class="number">1186.96</span>,</span><br><span class="line">    <span class="string">&#x27;IBM&#x27;</span>: <span class="number">149.24</span>,</span><br><span class="line">    <span class="string">&#x27;ORCL&#x27;</span>: <span class="number">48.44</span>,</span><br><span class="line">    <span class="string">&#x27;ACN&#x27;</span>: <span class="number">166.89</span>,</span><br><span class="line">    <span class="string">&#x27;FB&#x27;</span>: <span class="number">208.09</span>,</span><br><span class="line">    <span class="string">&#x27;SYMC&#x27;</span>: <span class="number">21.29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 用股票价格大于100元的股票构造一个新的字典</span></span><br><span class="line">prices2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">100</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(prices2)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">嵌套的列表的坑</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;赵云&#x27;</span>, <span class="string">&#x27;马超&#x27;</span>, <span class="string">&#x27;黄忠&#x27;</span>]</span><br><span class="line">courses = [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>]</span><br><span class="line"><span class="comment"># 录入五个学生三门课程的成绩</span></span><br><span class="line"><span class="comment"># 错误 - 参考http://pythontutor.com/visualize.html#mode=edit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># scores = [[None] * len(courses)] * len(names)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [None] 创建了一个包含一个 None 元素的列表。然后，通过乘法操作符 * 将该列表重复了 len(courses) 次。最终得到一个包含了多个相同的 [None] 子列表的列表。</span></span><br><span class="line"></span><br><span class="line">scores = [[<span class="literal">None</span>] * <span class="built_in">len</span>(courses) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names))]</span><br><span class="line"></span><br><span class="line"><span class="comment">#[None] * len(courses) 创建了一个包含 len(courses) 个 None 元素的列表。然后，列表推导式 [_ for _ in range(len(names))] 会遍历 range(len(names)) 中的每个索引值，并为每个索引值创建一个新的列表，其中包含 len(courses) 个 None 元素。</span></span><br><span class="line"></span><br><span class="line">这样做的结果是，对于 names 列表中的每个元素，都创建了一个新的包含 <span class="built_in">len</span>(courses) 个 <span class="literal">None</span> 元素的子列表，而不像之前的方法中那样，所有子列表都是相同的引用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">    <span class="keyword">for</span> col, course <span class="keyword">in</span> <span class="built_in">enumerate</span>(courses):</span><br><span class="line">        scores[row][col] = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">f&#x27;请输入<span class="subst">&#123;name&#125;</span>的<span class="subst">&#123;course&#125;</span>成绩: &#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(scores)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">heapq模块（堆排序）</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">从列表中找出最大的或最小的N个元素</span></span><br><span class="line"><span class="string">堆结构(大根堆/小根堆)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">99</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">58</span>, <span class="number">78</span>, <span class="number">88</span>, <span class="number">92</span>]</span><br><span class="line">list2 = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;FB&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;HPQ&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">35</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;YHOO&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">45</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ACME&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">3</span>, list1))</span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">3</span>, list1))</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">2</span>, list2, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;price&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">2</span>, list2, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;shares&#x27;</span>]))</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">itertools模块</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">迭代工具模块</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生ABCD的全排列</span></span><br><span class="line">itertools.permutations(<span class="string">&#x27;ABCD&#x27;</span>)</span><br><span class="line"><span class="comment"># 产生ABCDE的五选三组合</span></span><br><span class="line">itertools.combinations(<span class="string">&#x27;ABCDE&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 产生ABCD和123的笛卡尔积</span></span><br><span class="line">itertools.product(<span class="string">&#x27;ABCD&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="comment"># 产生ABC的无限循环序列</span></span><br><span class="line">itertools.cycle((<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>))</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">collections模块</span><br><span class="line"></span><br><span class="line">常用的工具类：</span><br><span class="line"></span><br><span class="line">namedtuple：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</span><br><span class="line">deque：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而deque底层是双向链表，因此当你需要在头尾添加和删除元素时，deque会表现出更好的性能，渐近时间复杂度为$O(<span class="number">1</span>)$。</span><br><span class="line">Counter：<span class="built_in">dict</span>的子类，键是元素，值是元素的计数，它的most_common()方法可以帮助我们获取出现频率最高的元素。Counter和<span class="built_in">dict</span>的继承关系我认为是值得商榷的，按照CARP原则，Counter跟<span class="built_in">dict</span>的关系应该设计为关联关系更为合理。</span><br><span class="line">OrderedDict：<span class="built_in">dict</span>的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</span><br><span class="line">defaultdict：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的setdefault()方法，这种做法更加高效。</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">找出序列中出现次数最多的元素</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">words = [</span><br><span class="line">    <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;around&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&quot;don&#x27;t&quot;</span>, <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;around&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&quot;you&#x27;re&quot;</span>, <span class="string">&#x27;under&#x27;</span></span><br><span class="line">]</span><br><span class="line">counter = Counter(words)</span><br><span class="line"><span class="built_in">print</span>(counter.most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<p>排序算法（选择、冒泡和归并）和查找算法（顺序和折半）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">items, comp=<span class="keyword">lambda</span> x, y: x &lt; y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单选择排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 复制一份待排序的列表，避免修改原列表</span></span><br><span class="line">    items = items[:]  <span class="comment"># 复制列表</span></span><br><span class="line">    <span class="comment"># 外层循环，遍历待排序的列表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items) - <span class="number">1</span>):</span><br><span class="line">        min_index = i  <span class="comment"># 将当前索引设为最小值索引</span></span><br><span class="line">        <span class="comment"># 内层循环，从当前位置的下一个位置开始遍历到列表末尾</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">            <span class="comment"># 使用 comp 函数判断当前元素是否比最小值索引处的元素小</span></span><br><span class="line">            <span class="keyword">if</span> comp(items[j], items[min_index]):</span><br><span class="line">                min_index = j  <span class="comment"># 更新最小值索引</span></span><br><span class="line">        <span class="comment"># 将最小值索引处的元素与当前位置的元素交换</span></span><br><span class="line">        items[i], items[min_index] = items[min_index], items[i]</span><br><span class="line">    <span class="comment"># 返回排序后的列表</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">items, comp=<span class="keyword">lambda</span> x, y: x &gt; y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items) - <span class="number">1</span>):</span><br><span class="line">        swapped = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items) - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> comp(items[j], items[j + <span class="number">1</span>]):</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">items, comp=<span class="keyword">lambda</span> x, y: x &gt; y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;搅拌排序(冒泡排序升级版)&quot;&quot;&quot;</span></span><br><span class="line">    items = items[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items) - <span class="number">1</span>):</span><br><span class="line">        swapped = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items) - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> comp(items[j], items[j + <span class="number">1</span>]):</span><br><span class="line">                items[j], items[j + <span class="number">1</span>] = items[j + <span class="number">1</span>], items[j]</span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> swapped:</span><br><span class="line">            swapped = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(items) - <span class="number">2</span> - i, i, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> comp(items[j - <span class="number">1</span>], items[j]):</span><br><span class="line">                    items[j], items[j - <span class="number">1</span>] = items[j - <span class="number">1</span>], items[j]</span><br><span class="line">                    swapped = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seq_search</span>(<span class="params">items, key</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;顺序查找&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># items：待查找的列表；key：要查找的关键字</span></span><br><span class="line">    <span class="comment"># enumerate() 函数用于将一个可遍历的数据对象组合为一个索引序列，同时列出数据和数据下标，返回 (index, item) 元组</span></span><br><span class="line">    <span class="comment"># index 表示当前元素的索引，item 表示当前元素的值</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(items):</span><br><span class="line">        <span class="comment"># 遍历待查找的列表，逐个检查元素是否等于要查找的关键字</span></span><br><span class="line">        <span class="keyword">if</span> item == key:  <span class="comment"># 如果找到了与关键字相等的元素</span></span><br><span class="line">            <span class="keyword">return</span> index  <span class="comment"># 返回该元素在列表中的索引</span></span><br><span class="line">    <span class="comment"># 若未找到与关键字相等的元素，则返回 -1，表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 返回 -1 表示未找到关键字</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">items1, items2, comp=<span class="keyword">lambda</span> x, y: x &lt; y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并(将两个有序的列表合并成一个有序的列表)&quot;&quot;&quot;</span></span><br><span class="line">    items = []</span><br><span class="line">    index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index1 &lt; <span class="built_in">len</span>(items1) <span class="keyword">and</span> index2 &lt; <span class="built_in">len</span>(items2):</span><br><span class="line">        <span class="keyword">if</span> comp(items1[index1], items2[index2]):</span><br><span class="line">            items.append(items1[index1])</span><br><span class="line">            index1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items.append(items2[index2])</span><br><span class="line">            index2 += <span class="number">1</span></span><br><span class="line">    items += items1[index1:]</span><br><span class="line">    items += items2[index2:]</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">items, comp=<span class="keyword">lambda</span> x, y: x &lt; y</span>):</span><br><span class="line">    <span class="keyword">return</span> _merge_sort(<span class="built_in">list</span>(items), comp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_merge_sort</span>(<span class="params">items, comp</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;归并排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(items) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> items</span><br><span class="line">    mid = <span class="built_in">len</span>(items) // <span class="number">2</span></span><br><span class="line">    left = _merge_sort(items[:mid], comp)</span><br><span class="line">    right = _merge_sort(items[mid:], comp)</span><br><span class="line">    <span class="keyword">return</span> merge(left, right, comp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">items, key</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;折半查找&quot;&quot;&quot;</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(items) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key &gt; items[mid]:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> key &lt; items[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a><strong>常用算法</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</span><br><span class="line">贪婪法 - 在对问题求解时，总是做出在当前看来最好的选择，不追求最优解，快速找到满意解。</span><br><span class="line">分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</span><br><span class="line">回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</span><br><span class="line">动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</span><br></pre></td></tr></table></figure>

<p><code>map()</code> 函数是 Python 内置的函数之一，用于对可<strong>迭代</strong>对象中的每个元素应用指定的函数，返回一个<strong>结果列表</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br><span class="line">function：表示要对可迭代对象中的每个元素执行的函数。</span><br><span class="line">iterable：表示一个或多个可迭代对象，可以是列表、元组、集合等。</span><br><span class="line">...：可以传入多个可迭代对象，如果有多个可迭代对象，map() 函数会以并行的方式对每个可迭代对象的元素应用函数。</span><br><span class="line">map() 函数会返回一个迭代器对象，可以使用 list() 函数将其转换为列表，或者在需要时直接进行迭代。</span><br></pre></td></tr></table></figure>



<p>动态规划例子：子列表元素之和的最大值。</p>
<blockquote>
<p>说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p>
<p>输入：1 -2 3 5 -3 2</p>
<p>输出：8</p>
<p>输入：0 -2 3 5 -1 2</p>
<p>输出：9</p>
<p>输入：-9 -2 -3 -5 -3</p>
<p>输出：-2</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    items = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    overall = partial = items[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(items)):</span><br><span class="line">        partial = <span class="built_in">max</span>(items[i], partial + items[i])</span><br><span class="line">        overall = <span class="built_in">max</span>(partial, overall)</span><br><span class="line">    <span class="built_in">print</span>(overall)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来$O(N^2)$复杂度的问题变成了$O(N)$。</p>
<h2 id="闭包（Closure）和作用域（Scope）"><a href="#闭包（Closure）和作用域（Scope）" class="headerlink" title="闭包（Closure）和作用域（Scope）"></a>闭包（Closure）和作用域（Scope）</h2><p>闭包（Closure）和作用域（Scope）是 Python 中的两个重要概念，它们经常一起讨论，因为闭包的特性与作用域密切相关。</p>
<ol>
<li><p><strong>作用域（Scope）</strong>：</p>
<ul>
<li>作用域指的是在程序中变量的有效范围，即变量可以被访问的区域。Python 中有以下几种作用域：<ul>
<li>全局作用域（Global Scope）：在整个程序中都可见的作用域，包括模块级别的作用域。</li>
<li>局部作用域（Local Scope）：在函数内部定义的作用域，只在函数内部可见。</li>
<li>嵌套作用域（Enclosing Scope）：在函数嵌套中的作用域，外层函数的作用域可以被内层函数访问。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>闭包（Closure）</strong>：</p>
<ul>
<li>闭包是指内部函数（嵌套函数）可以访问外部函数作用域中的变量，并且可以在外部函数返回后继续访问这些变量。</li>
<li>当内部函数引用了外部函数的局部变量，并将内部函数作为返回值返回时，就形成了闭包。</li>
<li>闭包可以用来<strong>保持状态</strong>，实现类似于面向对象编程中的对象的特性。</li>
</ul>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 外部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="comment"># 内部函数</span></span><br><span class="line">        <span class="keyword">return</span> x + y  <span class="comment"># 内部函数访问外部函数的局部变量 x</span></span><br><span class="line">    <span class="keyword">return</span> inner_function  <span class="comment"># 外部函数返回内部函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建闭包</span></span><br><span class="line">closure = outer_function(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用闭包</span></span><br><span class="line">result = closure(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：8，因为 closure 是闭包，可以访问 outer_function 的局部变量 x，即 x=5，所以结果是 5 + 3 = 8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="函数的元信息-装饰器"><a href="#函数的元信息-装饰器" class="headerlink" title="函数的元信息 装饰器"></a>函数的元信息 装饰器</h2><p>在 Python 中，函数的<strong>元信息</strong>是指函数对象中的一些属性，例如函数的名称、文档字符串、参数列表等。保留函数的元信息可以提高代码的可读性和可维护性，使得代码更易于理解和调试。</p>
<p><code>@wraps</code> 是 <code>functools</code> 模块中的一个装饰器，用于将被装饰函数的元信息复制到装饰器函数中</p>
<p><strong>装饰器</strong>是 Python 中一种非常强大和常用的编程工具，它允许在不修改原函数代码的情况下，对函数进行功能的增强、扩展或修改。装饰器本质上是一个函数，<strong>它接受一个函数作为参数，并返回一个新的函数</strong>。</p>
<p>在 Python 中，装饰器通常用于以下情况：</p>
<ol>
<li><strong>日志记录</strong>：记录函数的调用时间、参数和返回值等信息。</li>
<li><strong>性能分析</strong>：统计函数的执行时间，帮助优化性能。</li>
<li><strong>权限控制</strong>：验证用户的身份或权限，确定是否允许执行函数。</li>
<li><strong>缓存</strong>：缓存函数的计算结果，提高程序的运行效率。</li>
<li><strong>异常处理</strong>：捕获函数中的异常并进行处理。</li>
<li><strong>事务管理</strong>：在函数执行前后进行事务的开始和提交等操作。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  <span class="comment"># 导入 wraps 函数，用于保留被装饰函数的元信息</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time  <span class="comment"># 导入 time 函数，用于记录时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">record_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义装饰函数的装饰器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 定义一个装饰器函数，用于记录被装饰函数的执行时间，并返回执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)  </span><span class="comment"># 使用 wraps 装饰器，保留被装饰函数的元信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    		<span class="comment">#*args, **kwargs 接受任意数量的位置参数和关键字参数 既被装饰函数。</span></span><br><span class="line">        <span class="comment"># 定义一个内部包装函数，接受任意数量的位置参数和关键字参数</span></span><br><span class="line">        start = time()  <span class="comment"># 记录当前时间作为函数执行开始时间</span></span><br><span class="line">        result = func(*args, **kwargs)  <span class="comment"># 调用被装饰函数，并获取其返回值</span></span><br><span class="line">        <span class="comment"># 计算函数执行时间，并打印输出</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>: <span class="subst">&#123;time() - start&#125;</span>秒&#x27;</span>)  <span class="comment"># 输出函数名及执行时间</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回被装饰函数的执行结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回内部包装函数作为装饰器的返回值</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@record_time</span></span><br><span class="line"><span class="keyword">def</span>......</span><br></pre></td></tr></table></figure>



<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式</strong>是一种设计模式，其主要目的是确保类在程序中只有一个实例，并提供全局访问点来访问该实例。单例模式的主要用途包括：</p>
<ol>
<li><strong>资源共享</strong>：单例模式可以用于管理共享的资源，例如数据库连接、文件系统等。通过使用单例模式，可以确保在整个程序中只有一个资源实例，避免资源的重复创建和浪费。</li>
<li><strong>全局状态共享</strong>：单例模式可以用于管理全局状态，例如应用程序的配置信息、日志记录器等。通过使用单例模式，可以确保在整个程序中只有一个状态实例，方便在不同模块之间共享状态信息。</li>
<li><strong>线程池、连接池等管理器</strong>：单例模式可以用于管理线程池、连接池等资源管理器。通过使用单例模式，可以确保在整个程序中只有一个资源管理器实例，避免资源的竞争和冲突。</li>
<li><strong>避免重复创建实例</strong>：单例模式可以避免在程序中重复创建实例，提高了程序的性能和效率。例如，对于某些需要频繁创建的对象，可以使用单例模式来确保只有一个实例存在，避免了重复创建和销毁的开销。</li>
<li><strong>全局访问点</strong>：单例模式提供了一个全局访问点来访问实例，方便在程序的任何地方都可以访问到该实例。这种全局访问点可以简化代码的调用和管理，提高了程序的可维护性和可读性。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  <span class="comment"># 导入 wraps 装饰器，用于保留被装饰类的元信息</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> RLock  <span class="comment"># 导入 RLock 类，用于创建线程安全的锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线程安全的单例装饰器&quot;&quot;&quot;</span></span><br><span class="line">    instances = &#123;&#125;  <span class="comment"># 用于存储各个类的实例的字典</span></span><br><span class="line">    locker = RLock()  <span class="comment"># 创建一个线程安全的锁对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">cls</span>)  </span><span class="comment"># 使用 wraps 装饰器，保留被装饰类的元信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:  <span class="comment"># 如果该类不在实例字典中</span></span><br><span class="line">            <span class="keyword">with</span> locker:  <span class="comment"># 使用线程安全的锁</span></span><br><span class="line">                <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:  <span class="comment"># 再次检查，防止并发创建实例</span></span><br><span class="line">                    instances[cls] = cls(*args, **kwargs)  <span class="comment"># 创建该类的实例并存储在字典中</span></span><br><span class="line">        <span class="keyword">return</span> instances[cls]  <span class="comment"># 返回该类的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回装饰器函数</span></span><br></pre></td></tr></table></figure>

<p><code>RLock()</code> 是 Python 中 <code>threading</code> 模块中的一个类，用于创建可重入锁（Reentrant Lock）对象。</p>
<p>可重入锁是一种特殊的锁，允许同一线程多次请求锁，而不会造成死锁。如果一个线程已经持有了该锁，那么它可以再次获取该锁，而其他线程在此期间会被阻塞。当线程释放所有的锁时，其他线程才能获取锁。</p>
<p><code>RLock()</code> 类的对象具有以下几种方法：</p>
<ul>
<li><code>acquire([blocking])</code>：获取锁。如果 <code>blocking</code> 参数为 <code>True</code>，则会阻塞直到获取锁；如果为 <code>False</code>，则会立即返回获取锁的结果。</li>
<li><code>release()</code>：释放锁。</li>
<li><code>locked()</code>：返回当前锁的状态，如果已经被锁定，则返回 <code>True</code>，否则返回 <code>False</code>。</li>
<li><code>__enter__()</code> 和 <code>__exit__()</code>：用于支持上下文管理器协议，可以使用 <code>with</code> 语句来管理锁的获取和释放。</li>
</ul>
<p>可重入锁适用于多线程环境下需要对临界资源进行保护的场景，可以避免死锁和提高性能。在使用多个锁时，可重入锁比普通锁更加灵活，因为同一线程可以多次获取同一个可重入锁而不会发生死锁。</p>
<h2 id="抽象基类（Abstract-Base-Class）"><a href="#抽象基类（Abstract-Base-Class）" class="headerlink" title="抽象基类（Abstract Base Class）"></a><strong>抽象基类</strong>（Abstract Base Class）</h2><p><strong><code>abc</code> 模块</strong>是 Python 标准库中的一个模块，用于支持<strong>抽象基类</strong>（Abstract Base Class）的定义和使用。抽象基类是一种特殊的类，它不能被实例化，只能被用作其他类的基类，并定义了一组抽象方法的接口。子类必须实现这些抽象方法，否则在实例化子类时会抛出 <code>TypeError</code> 异常。</p>
<p><code>abc</code> 模块主要提供了以下几个重要的类和函数：</p>
<ol>
<li><code>ABC</code>：抽象基类的基类。继承自 <code>ABCMeta</code> 元类，用于定义抽象基类。</li>
<li><code>abstractmethod</code>：抽象方法的装饰器。用于定义抽象方法，必须在抽象基类中使用。</li>
<li><code>abstractproperty</code>：抽象属性的装饰器。用于定义抽象属性，必须在抽象基类中使用。</li>
<li><code>abstractstaticmethod</code>：抽象静态方法的装饰器。用于定义抽象静态方法，必须在抽象基类中使用。</li>
<li><code>abstractclassmethod</code>：抽象类方法的装饰器。用于定义抽象类方法，必须在抽象基类中使用。</li>
</ol>
<p>使用 <code>abc</code> 模块可以帮助开发者更好地<strong>组织和管理</strong>代码，提高代码的可读性和可维护性，同时还能够通过<strong>强制子类实现抽象方法</strong>来提高代码的健壮性和可靠性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;员工(抽象类)&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;结算月薪(抽象方法)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;部门经理&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;程序员&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, working_hour=<span class="number">0</span></span>):</span><br><span class="line">        self.working_hour = working_hour</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200.0</span> * self.working_hour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;销售员&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, sales=<span class="number">0.0</span></span>):</span><br><span class="line">        self.sales = sales</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1800.0</span> + self.sales * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeFactory</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod </span><span class="comment">#**`@staticmethod`** 是一个 Python 装饰器，用于定义**静态方法**。静态方法是属于类的方法，但与类的实例无关，因此它们不需要访问类的实例变量。静态方法通常用于**与类相关的功能**</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">emp_type, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建员工&quot;&quot;&quot;</span></span><br><span class="line">        all_emp_types = &#123;<span class="string">&#x27;M&#x27;</span>: Manager, <span class="string">&#x27;P&#x27;</span>: Programmer, <span class="string">&#x27;S&#x27;</span>: Salesman&#125;</span><br><span class="line">        cls = all_emp_types[emp_type.upper()]<span class="comment"># 根据员工类型获取对应的类 .upper() 是 Python 字符串对象的一个方法，用于将字符串中的所有字符转换为大写形式，并返回转换后的新字符串。</span></span><br><span class="line">        <span class="keyword">return</span> cls(*args, **kwargs) <span class="keyword">if</span> cls <span class="keyword">else</span> <span class="literal">None</span><span class="comment"># 创建对应类型的员工对象，并传入参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    emps = [</span><br><span class="line">        EmployeeFactory.create(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;曹操&#x27;</span>), <span class="comment"># 创建部门经理</span></span><br><span class="line">        EmployeeFactory.create(<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;荀彧&#x27;</span>, <span class="number">120</span>),</span><br><span class="line">        EmployeeFactory.create(<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;郭嘉&#x27;</span>, <span class="number">85</span>), </span><br><span class="line">        EmployeeFactory.create(<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;典韦&#x27;</span>, <span class="number">123000</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;emp.name&#125;</span>: <span class="subst">&#123;emp.get_salary():<span class="number">.2</span>f&#125;</span>元&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="枚举（Enumeration）类型"><a href="#枚举（Enumeration）类型" class="headerlink" title="枚举（Enumeration）类型"></a>枚举（Enumeration）类型</h2><p><strong><code>enum</code></strong> 是 Python 中的一个模块，用于创建枚举（Enumeration）类型。</p>
<p>枚举类型是一种<strong>有限的、预定义的、可以命名的值的集合</strong>。在某些情况下，使用枚举可以使代码更加<strong>清晰、可读</strong>，避免使用零散的常量或者硬编码的值。</p>
<p>Python 的枚举模块 <code>enum</code> 提供了 <code>Enum</code> 类，用于创建枚举类型。使用枚举类型可以定义一组具名的常量，这些常量在整个程序中保持不变，可以通过名称来引用。</p>
<p><code>unique</code> 是 Python 中 <code>enum</code> 模块提供的一个装饰器，用于标记枚举类中的成员值是否唯一。在使用 <code>unique</code> 装饰器时，如果枚举类中存在重复的成员值，Python 解释器会抛出 <code>ValueError</code> 异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique  <span class="comment"># 导入 Enum 类和 unique 装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random  <span class="comment"># 导入 random 模块，用于洗牌</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@unique  </span><span class="comment"># 唯一装饰器，用于确保枚举值的唯一性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Suite</span>(<span class="title class_ inherited__">Enum</span>):  <span class="comment"># 定义花色枚举类型</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;花色&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    SPADE, HEART, CLUB, DIAMOND = <span class="built_in">range</span>(<span class="number">4</span>)  <span class="comment"># 定义四种花色，使用 range 函数生成枚举值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):  <span class="comment"># 定义小于比较方法，用于排序</span></span><br><span class="line">        <span class="keyword">return</span> self.value &lt; other.value  <span class="comment"># 返回当前枚举值与另一个枚举值的大小比较结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Card</span>:  <span class="comment"># 定义牌类</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;牌&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, suite, face</span>):  <span class="comment"># 初始化方法，传入花色和牌面值</span></span><br><span class="line">        self.suite = suite  <span class="comment"># 花色</span></span><br><span class="line">        self.face = face  <span class="comment"># 牌面值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):  <span class="comment"># 显示牌面方法</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示牌面&quot;&quot;&quot;</span></span><br><span class="line">        suites = [<span class="string">&#x27;♠︎&#x27;</span>, <span class="string">&#x27;♥︎&#x27;</span>, <span class="string">&#x27;♣︎&#x27;</span>, <span class="string">&#x27;♦︎&#x27;</span>]  <span class="comment"># 四种花色的符号列表</span></span><br><span class="line">        faces = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>]  <span class="comment"># 牌面值列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;suites[self.suite.value]&#125;</span><span class="subst">&#123;faces[self.face]&#125;</span>&#x27;</span>  <span class="comment"># 返回牌的花色和牌面值的组合字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):  <span class="comment"># 重写 __repr__ 方法，用于打印牌的信息</span></span><br><span class="line">        <span class="keyword">return</span> self.show()  <span class="comment"># 调用 show 方法返回牌的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poker</span>:  <span class="comment"># 定义扑克牌类</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;扑克&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  <span class="comment"># 初始化方法</span></span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 牌的索引</span></span><br><span class="line">        self.cards = [Card(suite, face)  <span class="comment"># 创建一副扑克牌，包括四种花色和 1-13 的牌面值</span></span><br><span class="line">                      <span class="keyword">for</span> suite <span class="keyword">in</span> Suite</span><br><span class="line">                      <span class="keyword">for</span> face <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shuffle</span>(<span class="params">self</span>):  <span class="comment"># 洗牌方法</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;洗牌（随机乱序）&quot;&quot;&quot;</span></span><br><span class="line">        random.shuffle(self.cards)  <span class="comment"># 使用 random 模块中的 shuffle 函数对牌进行洗牌</span></span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 重置牌的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deal</span>(<span class="params">self</span>):  <span class="comment"># 发牌方法</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;发牌&quot;&quot;&quot;</span></span><br><span class="line">        card = self.cards[self.index]  <span class="comment"># 获取当前索引位置的牌</span></span><br><span class="line">        self.index += <span class="number">1</span>  <span class="comment"># 索引加一，指向下一张牌</span></span><br><span class="line">        <span class="keyword">return</span> card  <span class="comment"># 返回发出的牌</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_more</span>(<span class="params">self</span>):  <span class="comment"># 判断是否还有牌</span></span><br><span class="line">        <span class="keyword">return</span> self.index &lt; <span class="built_in">len</span>(self.cards)  <span class="comment"># 判断当前索引是否小于牌的总数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:  <span class="comment"># 定义玩家类</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;玩家&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):  <span class="comment"># 初始化方法，传入玩家姓名</span></span><br><span class="line">        self.name = name  <span class="comment"># 玩家姓名</span></span><br><span class="line">        self.cards = []  <span class="comment"># 玩家手中的牌列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_one</span>(<span class="params">self, card</span>):  <span class="comment"># 摸一张牌方法，传入一张牌对象</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;摸一张牌&quot;&quot;&quot;</span></span><br><span class="line">        self.cards.append(card)  <span class="comment"># 将摸到的牌加入到手中牌的列表中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">self, comp=<span class="keyword">lambda</span> card: (<span class="params">card.suite, card.face</span>)</span>):  <span class="comment"># 整理手上的牌方法，传入一个比较函数，默认按花色和牌面值排序</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;整理手上的牌&quot;&quot;&quot;</span></span><br><span class="line">        self.cards.sort(key=comp)  <span class="comment"># 使用列表的 sort 方法对手中的牌进行排序，传入比较函数进行排序规则的指定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  <span class="comment"># 主函数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    poker = Poker()  <span class="comment"># 创建一副扑克牌对象</span></span><br><span class="line">    poker.shuffle()  <span class="comment"># 洗牌</span></span><br><span class="line">    players = [Player(<span class="string">&#x27;东邪&#x27;</span>), Player(<span class="string">&#x27;西毒&#x27;</span>), Player(<span class="string">&#x27;南帝&#x27;</span>), Player(<span class="string">&#x27;北丐&#x27;</span>)]  <span class="comment"># 创建四个玩家对象</span></span><br><span class="line">    <span class="keyword">while</span> poker.has_more:  <span class="comment"># 当还有牌未发完时循环</span></span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:  <span class="comment"># 遍历每个玩家</span></span><br><span class="line">                player.get_one(poker.deal())  <span class="comment"># 给每个玩家发一张牌</span></span><br><span class="line">    <span class="keyword">for</span> player <span class="keyword">in</span> players:  <span class="comment"># 遍历每个玩家</span></span><br><span class="line">        player.sort()  <span class="comment"># 整理每个玩家手上的牌</span></span><br><span class="line">        <span class="built_in">print</span>(player.name, end=<span class="string">&#x27;: &#x27;</span>)  <span class="comment"># 打印玩家姓名</span></span><br><span class="line">        <span class="built_in">print</span>(player.cards)  <span class="comment"># 打印玩家手中的牌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># 判断是否在主程序中执行</span></span><br><span class="line">    main()  <span class="comment"># 调用主函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="对象的复制（深复制-深拷贝-深度克隆和浅复制-浅拷贝-影子克隆）"><a href="#对象的复制（深复制-深拷贝-深度克隆和浅复制-浅拷贝-影子克隆）" class="headerlink" title="对象的复制（深复制&#x2F;深拷贝&#x2F;深度克隆和浅复制&#x2F;浅拷贝&#x2F;影子克隆）"></a>对象的复制（深复制&#x2F;深拷贝&#x2F;深度克隆和浅复制&#x2F;浅拷贝&#x2F;影子克隆）</h2><p><strong>浅复制</strong>（Shallow Copy）：创建一个新对象，该对象与原始对象具有相同的内容，但是只复制了对象的一层，而不是递归地复制嵌套对象。因此，<strong>如果原始对象包含可变对象（例如列表或字典），则浅复制后的对象中的这些可变对象仍然是共享的</strong>。可以使用 <code>copy()</code> 方法或 <code>copy</code> 模块中的 <code>copy()</code> 函数进行浅复制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">original_list = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line">shallow_copy = copy.copy(original_list)</span><br><span class="line"></span><br><span class="line">original_list[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(original_list)  <span class="comment"># 输出 [1, [5, 3], 4]</span></span><br><span class="line"><span class="built_in">print</span>(shallow_copy)   <span class="comment"># 输出 [1, [5, 3], 4]，可变对象列表共享</span></span><br></pre></td></tr></table></figure>

<p><strong>深复制</strong>（Deep Copy）：创建一个新对象，该对象与原始对象具有相同的内容，包括原始对象中的所有嵌套对象，递归地复制整个对象结构。因此，<strong>即使原始对象包含可变对象，深复制后的对象中的这些可变对象也是独立的，不会共享</strong>。可以使用 <code>copy()</code> 方法或 <code>copy</code> 模块中的 <code>deepcopy()</code> 函数进行深复制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">original_list = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line">deep_copy = copy.deepcopy(original_list)</span><br><span class="line"></span><br><span class="line">original_list[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(original_list)  <span class="comment"># 输出 [1, [5, 3], 4]</span></span><br><span class="line"><span class="built_in">print</span>(deep_copy)      <span class="comment"># 输出 [1, [2, 3], 4]，可变对象列表独立</span></span><br></pre></td></tr></table></figure>





<h2 id="垃圾回收、循环引用和弱引用"><a href="#垃圾回收、循环引用和弱引用" class="headerlink" title="垃圾回收、循环引用和弱引用"></a>垃圾回收、循环引用和弱引用</h2><p>Python 使用自动化内存管理，其垃圾回收机制主要基于<strong>引用计数</strong>、<strong>标记-清除</strong>和<strong>分代收集</strong>三种策略。</p>
<ul>
<li><strong>引用计数</strong>：Python 中的每个对象都有一个引用计数器，用于记录当前对象被引用的次数。当引用计数为 0 时，对象被自动回收。但是引用计数无法处理循环引用的情况，会导致内存泄漏。</li>
<li><strong>标记-清除</strong>：Python 垃圾回收器会定期扫描程序的内存空间，标记那些可达对象，然后清除未标记的对象。这种机制可以处理循环引用的情况。</li>
<li><strong>分代收集</strong>：Python 中将对象分为不同的代，年轻的对象放在新生代，老化的对象放在老年代。垃圾回收器会根据对象的代别采取不同的策略，例如新生代使用标记-清除，老年代使用分代回收。</li>
</ul>
<p>对于<strong>循环引用</strong>的处理，Python 中可以使用<strong>弱引用</strong>来解决。弱引用是一种对对象的引用，不会增加对象的引用计数，当对象的所有强引用都消失后，该对象会被自动回收。使用 <code>weakref</code> 模块可以创建弱引用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">weak_ref = weakref.ref(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> obj  <span class="comment"># 删除原始对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(weak_ref())  <span class="comment"># 输出 None，原始对象已被回收</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>弱引用适用于需要引用对象但不希望影响对象的生命周期的情况，例如缓存、观察者模式等。</p>
<h2 id="魔法属性和方法"><a href="#魔法属性和方法" class="headerlink" title="魔法属性和方法"></a>魔法属性和方法</h2><p>魔法属性和方法是 Python 中特殊的命名约定，它们以双下划线开头和结尾（例如 <code>__init__()</code>）。这些特殊的命名约定用于定义对象的特殊行为和属性，使得对象能够与 Python 的内置功能更好地集成。以下是一些常见的魔法属性和方法：</p>
<p>有几个小问题请大家思考：</p>
<ul>
<li><p>自定义的对象能不能使用运算符做运算？</p>
<p>  Python 中的运算符重载允许自定义对象使用内置运算符进行操作。通过实现相应的魔法方法，可以为自定义对象定义运算符行为。例如，通过实现 <code>__add__()</code> 方法，可以使对象支持加法操作；通过实现 <code>__sub__()</code> 方法，可以支持减法操作，以此类推。</p>
</li>
<li><p>自定义的对象能不能放到<code>set</code>中？能去重吗？</p>
<p>  自定义对象可以放入 <code>set</code> 中，而且 <code>set</code> 会自动去重。<code>set</code> 内部使用哈希表进行存储，因此对于可哈希的对象，都可以放入 <code>set</code> 中并实现去重。要使自定义对象可哈希，需要实现 <code>__hash__()</code> 和 <code>__eq__()</code> 方法。</p>
</li>
<li><p>自定义的对象能不能作为<code>dict</code>的键？</p>
<p>  与放入 <code>set</code> 中类似，自定义对象也可以作为 <code>dict</code> 的键。同样地，要使自定义对象作为 <code>dict</code> 的键，需要实现 <code>__hash__()</code> 和 <code>__eq__()</code> 方法。</p>
</li>
<li><p>自定义的对象能不能使用上下文语法？</p>
<p>  自定义对象可以实现上下文管理器，使其支持上下文语法。上下文管理器是通过实现 <code>__enter__()</code> 和 <code>__exit__()</code> 方法来实现的。当对象进入上下文时，<code>__enter__()</code> 方法会被调用；当退出上下文时，<code>__exit__()</code> 方法会被调用。这样，自定义对象就可以使用 <code>with</code> 语句进行管理。</p>
</li>
</ul>
<p>总而言之，通过合适地实现魔法方法，自定义对象可以与 Python 内置类型具有相似的行为，包括支持运算符操作、放入容器中、作为字典的键、以及使用上下文管理器。</p>
<h3 id="import"><a href="#import" class="headerlink" title="__import__()"></a><code>__import__()</code></h3><p>是 Python 的一个内置函数，用于动态地导入模块。虽然它可以实现与 <code>import</code> 语句相同的功能，但一般情况下，推荐使用 <code>import</code> 语句来导入模块，因为 <code>import</code> 更为直观和易读。</p>
<h3 id="iter-和-next"><a href="#iter-和-next" class="headerlink" title="__iter__() 和 __next__()"></a><code>__iter__()</code> 和 <code>__next__()</code></h3><p>是 Python 中迭代器协议的两个特殊方法，用于实现可迭代对象（Iterable）和迭代器（Iterator）的协议。</p>
<ol>
<li><code>__iter__()</code> 方法：<ul>
<li><code>__iter__()</code> 方法用于返回一个迭代器对象，它是可迭代对象的标识方法。</li>
<li>当你调用一个对象的 <code>__iter__()</code> 方法时，它应该返回一个迭代器对象，这个迭代器对象必须实现 <code>__next__()</code> 方法（或者在 Python 2.x 中实现 <code>next()</code> 方法）。</li>
<li>如果一个对象实现了 <code>__iter__()</code> 方法但没有实现 <code>__next__()</code> 方法，那么它就是一个可迭代对象，但不是一个迭代器，你可以通过调用它的 <code>iter()</code> 方法来获取一个迭代器。</li>
</ul>
</li>
<li><code>__next__()</code> 方法：<ul>
<li><code>__next__()</code> 方法用于返回可迭代对象中的下一个元素。</li>
<li>当你调用一个迭代器的 <code>__next__()</code> 方法时，它应该返回可迭代对象中的下一个元素，如果没有更多元素可以返回，则抛出 <code>StopIteration</code> 异常。</li>
<li>在 Python 2.x 中，<code>__next__()</code> 方法被称为 <code>next()</code> 方法。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的示例，演示了如何使用 <code>__iter__()</code> 和 <code>__next__()</code> 方法实现一个简单的迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, limit</span>):</span><br><span class="line">        self.limit = limit</span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; self.limit:</span><br><span class="line">            value = self.current</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个迭代器对象</span></span><br><span class="line">my_iter = MyIterator(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用迭代器遍历元素</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> my_iter:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MyIterator</code> 类实现了迭代器协议，它包含 <code>__iter__()</code> 方法返回自身，并包含 <code>__next__()</code> 方法用于返回迭代器中的下一个元素。通过调用 <code>for</code> 循环遍历迭代器对象时，会自动调用迭代器对象的 <code>__iter__()</code> 方法获取迭代器，并在每次迭代时调用 <code>__next__()</code> 方法获取下一个元素。</p>
<h2 id="混入（Mixin）"><a href="#混入（Mixin）" class="headerlink" title="混入（Mixin）"></a>混入（Mixin）</h2><p>混入（Mixin）是一种在面向对象编程中用于代码重用的技术。Mixin 类是一种不需要实例化的类，其目的是<strong>为其他类提供额外的功能</strong>，而不改变其原有的继承关系。</p>
<p>Mixin 类通常具有以下特点：</p>
<ol>
<li>Mixin 类通常不会被实例化，而是被其他类所继承。</li>
<li>Mixin 类通常只包含一些方法，而不包含任何实例属性。</li>
<li>Mixin 类的命名通常以 <code>Mixin</code> 结尾，以便清晰地表明其作用。</li>
</ol>
<p>Mixin 类的主要作用是<strong>将常用的功能封装成方法，并通过多重继承的方式，使得多个类可以共享这些功能</strong>，从而提高了代码的<strong>重用性和可维护性</strong>。</p>
<p>例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SetOnceMappingMixin</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义混入类&quot;&quot;&quot;</span></span><br><span class="line">    __slots__ = ()  <span class="comment"># 使用 __slots__ 魔法属性来限制类实例的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;重写 __setitem__ 方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:  <span class="comment"># 如果键已经存在于字典中</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="built_in">str</span>(key) + <span class="string">&#x27; already set&#x27;</span>)  <span class="comment"># 抛出 KeyError 异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__setitem__(key, value)  <span class="comment"># 调用父类的 __setitem__ 方法来设置键值对</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SetOnceDict</span>(SetOnceMappingMixin, <span class="built_in">dict</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义字典类，继承自 SetOnceMappingMixin 和 dict&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dict = SetOnceDict()  <span class="comment"># 创建一个 SetOnceDict 对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    my_dict[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;jackfrued&#x27;</span>  <span class="comment"># 尝试设置键 &#x27;username&#x27; 的值为 &#x27;jackfrued&#x27;</span></span><br><span class="line">    my_dict[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;hellokitty&#x27;</span>  <span class="comment"># 尝试再次设置键 &#x27;username&#x27; 的值为 &#x27;hellokitty&#x27;，会抛出 KeyError 异常</span></span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 捕获并忽略 KeyError 异常</span></span><br><span class="line"><span class="built_in">print</span>(my_dict)  <span class="comment"># 打印输出字典内容</span></span><br></pre></td></tr></table></figure>

<p><code>SetOnceMappingMixin</code> 是一个混入类，它包含了 <code>__setitem__()</code> 方法，用于设置字典中的键值对，并且会检查键是否已经存在，如果存在则抛出异常。<code>SetOnceDict</code> 类继承了 <code>SetOnceMappingMixin</code> 和内置的 <code>dict</code> 类，从而获得了混入类的功能。这样，通过创建 <code>SetOnceDict</code> 对象，就可以实现字典中键的只设置一次的功能。</p>
<h2 id="元编程和元类"><a href="#元编程和元类" class="headerlink" title="元编程和元类"></a>元编程和元类</h2><p>元编程（metaprogramming）是指在运行时操作或创建代码的能力。元编程允许程序在运行时自身修改、检查或创建代码结构。元编程可以通过反射（reflection）、装饰器（decorators）、动态代码生成（dynamic code generation）等技术来实现。</p>
<p>元编程的主要目的是使代码更加灵活、可扩展和易于维护。它可以用于自动生成重复性高的代码、实现通用的抽象框架、简化代码结构、实现领域特定语言（Domain Specific Language, DSL）等。</p>
<p>元类（metaclass）是一种特殊的类，它用于创建类。在 Python 中，一切皆对象，包括类本身也是对象，因此类也可以通过元类来创建。元类可以控制类的创建过程，允许在创建类时动态修改类的行为、属性和方法。元类常用于实现ORM框架、序列化库、插件系统等高级功能。</p>
<p>元编程和元类是 Python 中高级编程技术的重要组成部分，虽然它们可以让代码更加灵活和强大，但也容易引入复杂性，因此在使用时需要谨慎考虑。</p>
<p>例子：用元类实现单例模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading <span class="comment">#导入 threading 模块，用于实现线程锁。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义元类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, *args, **kwargs</span>): <span class="comment">#定义了元类的初始化方法。在这个方法中，首先调用了 super().__init__(*args, **kwargs)，确保了基类的初始化方法被正确调用。然后，初始化了两个类属性 __instance 和 __lock，分别用于保存单例对象和实现线程锁。</span></span><br><span class="line">        cls.__instance = <span class="literal">None</span></span><br><span class="line">        cls.__lock = threading.RLock()</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>): <span class="comment">#定义了元类的调用方法。这个方法在创建类的实例时被调用。在这个方法中，首先判断类属性 __instance 是否为空，如果为空，则使用线程锁确保只有一个线程可以创建对象。然后再次判断 __instance 是否为空，这是为了避免在多线程环境下出现竞争条件。如果 __instance 为空，则调用基类的 __call__ 方法创建对象，并将其赋值给 __instance 属性。最后返回 __instance 属性。</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">with</span> cls.__lock:</span><br><span class="line">                <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    cls.__instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">President</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><ul>
<li>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）</li>
<li>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭</li>
<li>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）</li>
<li>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象</li>
<li>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python中没有接口的概念）</li>
<li>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码</li>
<li>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</li>
</ul>
<blockquote>
<p><strong>说明</strong>：上面加粗的字母放在一起称为面向对象的<strong>SOLID</strong>原则。</p>
</blockquote>
<h2 id="GoF设计模式"><a href="#GoF设计模式" class="headerlink" title="GoF设计模式"></a>GoF设计模式</h2><ul>
<li><p>创建型模式：单例、工厂、建造者、原型</p>
</li>
<li><p>结构型模式：适配器、门面（外观）、代理</p>
</li>
<li><p>行为型模式：迭代器、观察者、状态、策略</p>
<p>  例子：可插拔的哈希算法（策略模式）。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamHasher</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;哈希摘要生成器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, alg=<span class="string">&#x27;md5&#x27;</span>, size=<span class="number">4096</span></span>):</span><br><span class="line">        <span class="comment"># 初始化方法，接受两个可选参数：alg 表示哈希算法，默认为 md5；size 表示缓冲区大小，默认为 4096</span></span><br><span class="line">        self.size = size  <span class="comment"># 设置缓冲区大小</span></span><br><span class="line">        alg = alg.lower()  <span class="comment"># 将算法名称转换为小写</span></span><br><span class="line">        self.hasher = <span class="built_in">getattr</span>(<span class="built_in">__import__</span>(<span class="string">&#x27;hashlib&#x27;</span>), alg.lower())()  <span class="comment"># 根据算法名称创建哈希对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, stream</span>):</span><br><span class="line">        <span class="comment"># 调用方法，接受一个流对象作为输入，并返回其哈希摘要</span></span><br><span class="line">        <span class="keyword">return</span> self.to_digest(stream)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_digest</span>(<span class="params">self, stream</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成十六进制形式的摘要&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 定义生成摘要的方法，使用迭代器逐块读取流数据，每次读取 self.size 大小的数据块，并更新哈希对象的状态</span></span><br><span class="line">        <span class="keyword">for</span> buf <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: stream.read(self.size), <span class="string">b&#x27;&#x27;</span>):  <span class="comment"># 循环直到流读取完毕</span></span><br><span class="line">            self.hasher.update(buf)  <span class="comment"># 更新哈希对象的状态</span></span><br><span class="line">        <span class="keyword">return</span> self.hasher.hexdigest()  <span class="comment"># 返回哈希对象的十六进制摘要</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    hasher1 = StreamHasher()  <span class="comment"># 创建一个 StreamHasher 对象，使用默认的 MD5 算法和默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Python-3.7.6.tgz&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> stream:  <span class="comment"># 打开文件流</span></span><br><span class="line">        <span class="built_in">print</span>(hasher1.to_digest(stream))  <span class="comment"># 打印使用默认对象生成的哈希摘要</span></span><br><span class="line">    hasher2 = StreamHasher(<span class="string">&#x27;sha1&#x27;</span>)  <span class="comment"># 创建一个 StreamHasher 对象，使用 SHA1 算法和默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Python-3.7.6.tgz&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> stream:  <span class="comment"># 打开文件流</span></span><br><span class="line">        <span class="built_in">print</span>(hasher2(stream))  <span class="comment"># 打印使用指定对象生成的哈希摘要</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h2><p>是计算机科学中的一个重要概念，指的是在运行时检查、访问或者修改某个程序的状态、结构、属性和行为的能力。在 Python 中，反射是指通过一系列的内置函数和特殊属性，以及动态调用对象的属性和方法，实现在运行时对对象的操作。</p>
<p>Python 中常用的反射机制包括以下几个方面：</p>
<ol>
<li><strong>获取对象的属性和方法</strong>：通过 <code>getattr()</code> 函数获取对象的属性和方法。</li>
<li><strong>设置对象的属性</strong>：通过 <code>setattr()</code> 函数设置对象的属性。</li>
<li><strong>判断对象是否具有某个属性或者方法</strong>：通过 <code>hasattr()</code> 函数判断对象是否具有指定的属性或者方法。</li>
<li><strong>获取对象的类型信息</strong>：通过 <code>type()</code> 函数获取对象的类型。</li>
<li><strong>获取对象的成员列表</strong>：通过 <code>dir()</code> 函数获取对象的成员列表。</li>
<li><strong>调用对象的方法</strong>：通过动态调用对象的方法实现对对象行为的修改和控制。</li>
</ol>
<p>Python 的反射机制使得代码更加灵活和可扩展，可以根据需要在运行时动态地操作对象，从而实现更加智能和强大的功能。但是，过度使用反射也可能会导致代码可读性和维护性下降，因此在使用时需要谨慎考虑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.hasher = getattr(__import__(&#x27;hashlib&#x27;), alg.lower())()</span><br><span class="line"></span><br><span class="line">这行代码使用了 Python 中的动态属性访问和反射机制来根据传入的哈希算法名称动态地创建对应的哈希对象。</span><br><span class="line"></span><br><span class="line">让我们逐步解释这行代码：</span><br><span class="line"></span><br><span class="line">__import__(&#x27;hashlib&#x27;): 这是一个内置函数，用于动态导入模块。在这里，它导入了 hashlib 模块，该模块提供了一系列常用的哈希算法实现。</span><br><span class="line"></span><br><span class="line">alg.lower(): 这是将传入的哈希算法名称转换为小写，因为哈希算法名称通常不区分大小写，而 hashlib 模块中的哈希算法名称是小写的。</span><br><span class="line"></span><br><span class="line">getattr(__import__(&#x27;hashlib&#x27;), alg.lower()): 这是 Python 中的反射机制，getattr() 函数用于获取对象的属性或方法。在这里，它获取了 hashlib 模块中对应名称的属性，即指定的哈希算法。</span><br><span class="line"></span><br><span class="line">()：这是对获取的哈希算法对象进行调用，相当于创建了一个哈希对象实例。这样，self.hasher 就指向了具体的哈希算法对象，可以使用它来进行哈希计算。</span><br><span class="line"></span><br><span class="line">综上所述，这行代码实现了根据传入的哈希算法名称动态地创建对应的哈希对象实例，并将其保存在 self.hasher 属性中，以便后续使用。</span><br></pre></td></tr></table></figure>

<h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a><code>getattr()</code></h3><p><code>getattr()</code> 函数在动态编程和反射机制中经常被使用，它可以使代码更加<strong>灵活和可扩展</strong>。</p>
<p>是 Python 内置函数之一，用于获取对象的属性或者方法。其语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(<span class="built_in">object</span>, name[, default])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>object</code>：表示要获取属性或者方法的对象。</li>
<li><code>name</code>：表示要获取的属性或者方法的名称。</li>
<li><code>default</code>：可选参数，表示如果指定的属性或者方法不存在时，返回的默认值。</li>
</ul>
<p><code>getattr()</code> 的作用相当于使用点操作符（<code>.</code>）获取对象的属性或者方法，但是它更加灵活，可以通过变量的方式来指定要获取的属性或者方法名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.value = <span class="number">42</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取对象的属性值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;value&#x27;</span>))  <span class="comment"># 输出: 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取对象的方法并调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;method&#x27;</span>)())  <span class="comment"># 输出: Hello, world!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取不存在的属性时，会引发 AttributeError 异常</span></span><br><span class="line"><span class="comment"># print(getattr(obj, &#x27;nonexistent&#x27;))  # 抛出 AttributeError 异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过指定默认值避免异常</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(obj, <span class="string">&#x27;nonexistent&#x27;</span>, <span class="string">&#x27;default value&#x27;</span>))  <span class="comment"># 输出: default value</span></span><br></pre></td></tr></table></figure>

<h3 id="哈希算法（Hash-algorithm）"><a href="#哈希算法（Hash-algorithm）" class="headerlink" title="哈希算法（Hash algorithm）"></a>哈希算法（Hash algorithm）</h3><p>是一种将任意大小的数据映射到固定大小的数据的函数。哈希算法的输入可以是任意长度的数据，但输出的哈希值（或摘要）的长度通常是固定的。</p>
<p>哈希算法的主要特点包括：</p>
<ol>
<li><strong>确定性</strong>：对于相同的输入，哈希算法总是生成相同的输出。这意味着相同的数据经过哈希运算后，将得到相同的哈希值。</li>
<li><strong>不可逆性</strong>：哈希算法是单向的，即无法从哈希值推导出原始数据。即使原始数据只有微小的变化，其哈希值也会发生较大的变化。</li>
<li><strong>雪崩效应</strong>：稍微改变输入数据，即使只有一个比特位的变化，也会导致输出的哈希值发生巨大的变化。</li>
<li><strong>固定输出长度</strong>：哈希算法的输出长度通常是固定的，无论输入数据的大小。</li>
</ol>
<p>常见的哈希算法包括：</p>
<ul>
<li>MD5（Message Digest Algorithm 5）：产生128位的哈希值，已被证实存在碰撞，不建议用于安全目的。</li>
<li>SHA-1（Secure Hash Algorithm 1）：产生160位的哈希值，也存在碰撞问题，不再被推荐用于安全目的。</li>
<li>SHA-256、SHA-384、SHA-512：SHA-2 系列，产生不同长度的哈希值，较 SHA-1 更安全。</li>
<li>SHA-3（Secure Hash Algorithm 3）：基于 Keccak 算法，也是 NIST 的一个标准算法。</li>
</ul>
<p>在实际应用中，选择合适的哈希算法取决于具体的需求和安全要求。</p>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><ul>
<li><p>迭代器是实现了迭代器协议的对象。</p>
<ul>
<li>Python中没有像<code>protocol</code>或<code>interface</code>这样的定义协议的关键字。</li>
<li>Python中用魔术方法表示协议。</li>
<li><code>__iter__</code>和<code>__next__</code>魔术方法就是迭代器协议。</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;迭代器&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        self.num = num</span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.idx &lt; self.num:</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.a</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器是语法简化版的迭代器。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成器&quot;&quot;&quot;</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br></pre></td></tr></table></figure>

<p>  <code>yield</code> 是 Python 中的一个关键字，用于定义生成器（Generator）。生成器是一种<strong>特殊的迭代器，可以通过生成器来生成一系列值，并且可以在迭代过程中保持局部状态，从而节省内存和提高性能</strong>。</p>
<p>  当函数包含了 <code>yield</code> 语句时，它就成为了一个生成器函数。<code>yield</code> 关键字用于向调用者（迭代器）返回一个值，并且暂停函数的执行，保存函数的当前状态（包括局部变量的值和执行位置）。下次调用生成器时，函数会从上次暂停的地方继续执行，直到遇到下一个 <code>yield</code> 语句或者函数结束。</p>
<p>  <code>yield</code> 的作用类似于 <code>return</code>，但是它可以多次返回值，并且保持函数的执行状态，而不是完全退出函数。</p>
<p>  下面是一个简单的示例，演示了 <code>yield</code> 的用法：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>():</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器对象</span></span><br><span class="line">fib = fibonacci()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器遍历斐波那契数列的前 10 个数字</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(fib))</span><br></pre></td></tr></table></figure>

<p>  在这个示例中，<code>fibonacci</code> 函数是一个生成器函数，它使用了一个 while 循环来生成斐波那契数列。在每次迭代中，<code>yield a</code> 语句将当前的斐波那契数 <code>a</code> 返回给调用者，并暂停函数的执行。在下一次迭代时，函数会从 <code>yield</code> 语句后恢复执行，继续计算下一个斐波那契数。由于生成器函数保留了局部变量 <code>a</code> 和 <code>b</code> 的状态，因此可以在迭代过程中记住之前的计算结果，从而生成无限序列。</p>
</li>
<li><p>生成器进化为协程。</p>
<p>  生成器对象可以使用<code>send()</code>方法发送数据，发送的数据会成为<strong>生成器函数中通过<code>yield</code>表达式获得的值</strong>。这样，生成器就可以作为协程使用，<strong>协程简单的说就是可以相互协作的子程序</strong>。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_avg</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;流式计算平均值&quot;&quot;&quot;</span></span><br><span class="line">    total, counter = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    avg_value = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = <span class="keyword">yield</span> avg_value</span><br><span class="line">        total, counter = total + value, counter + <span class="number">1</span></span><br><span class="line">        avg_value = total / counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gen = calc_avg()<span class="comment"># 预激生成器，执行到第一个 yield 语句</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果没有预激生成器，即没有调用 next() 函数来启动生成器，直接调用 send() 方法将会引发 TypeError 异常。</span></span><br><span class="line"><span class="string">因为在生成器函数还没有被预激的情况下，生成器对象并没有执行到第一个 yield 语句，此时生成器函数处于未激活状态，无法接收外部发送的值。因此，直接调用 send() 方法会导致程序出错。</span></span><br><span class="line"><span class="string">生成器函数被称为&quot;未激活&quot;是因为生成器对象尚未被创建，生成器函数的代码也尚未开始执行。在这种状态下，无法使用生成器对象进行迭代或者发送值。只有当生成器函数被调用并且开始执行时，才会创建生成器对象，并且生成器函数的代码才会执行</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">next</span>(gen)</span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(gen.send(<span class="number">30</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>Python中实现并发编程的三种方案：多线程、多进程和异步I&#x2F;O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。</p>
<ul>
<li>多线程：Python中提供了<code>Thread</code>类并辅以<code>Lock</code>、<code>Condition</code>、<code>Event</code>、<code>Semaphore</code>和<code>Barrier</code>。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">面试题：进程和线程的区别和联系？</span></span><br><span class="line"><span class="string">进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程</span></span><br><span class="line"><span class="string">线程 - 操作系统分配CPU的基本单位</span></span><br><span class="line"><span class="string">并发编程（concurrent programming）</span></span><br><span class="line"><span class="string">1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行</span></span><br><span class="line"><span class="string">2. 改善用户体验 - 让耗时间的操作不会造成程序的假死</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> glob  <span class="comment"># 导入 glob 模块，用于匹配文件路径</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment"># 导入 os 模块，用于文件操作</span></span><br><span class="line"><span class="keyword">import</span> threading  <span class="comment"># 导入 threading 模块，用于多线程处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  <span class="comment"># 从 PIL 模块中导入 Image 类，用于图像处理</span></span><br><span class="line"></span><br><span class="line">PREFIX = <span class="string">&#x27;thumbnails&#x27;</span>  <span class="comment"># 设置缩略图目录的前缀名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_thumbnail</span>(<span class="params">infile, size, <span class="built_in">format</span>=<span class="string">&#x27;PNG&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成指定图片文件的缩略图&quot;&quot;&quot;</span></span><br><span class="line">    file, ext = os.path.splitext(infile)  <span class="comment"># 分割文件路径和扩展名</span></span><br><span class="line">    file = file[file.rfind(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>:]  <span class="comment"># 从文件路径中提取文件名</span></span><br><span class="line">    outfile = <span class="string">f&#x27;<span class="subst">&#123;PREFIX&#125;</span>/<span class="subst">&#123;file&#125;</span>_<span class="subst">&#123;size[<span class="number">0</span>]&#125;</span>_<span class="subst">&#123;size[<span class="number">1</span>]&#125;</span>.<span class="subst">&#123;ext&#125;</span>&#x27;</span>  <span class="comment"># 设置输出文件路径</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(infile)  <span class="comment"># 打开原始图片文件</span></span><br><span class="line">    img.thumbnail(size, Image.ANTIALIAS)  <span class="comment"># 生成缩略图</span></span><br><span class="line">    img.save(outfile, <span class="built_in">format</span>)  <span class="comment"># 保存缩略图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(PREFIX):  <span class="comment"># 如果缩略图目录不存在，则创建它</span></span><br><span class="line">        os.mkdir(PREFIX)</span><br><span class="line">    <span class="keyword">for</span> infile <span class="keyword">in</span> glob.glob(<span class="string">&#x27;images/*.png&#x27;</span>):  <span class="comment"># 遍历指定目录下的所有 PNG 图片文件</span></span><br><span class="line">        <span class="keyword">for</span> size <span class="keyword">in</span> (<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>):  <span class="comment"># 遍历不同尺寸</span></span><br><span class="line">            <span class="comment"># 创建并启动线程</span></span><br><span class="line">            threading.Thread(</span><br><span class="line">                target=generate_thumbnail,  <span class="comment"># 指定线程执行的函数</span></span><br><span class="line">                args=(infile, (size, size))  <span class="comment"># 指定函数参数</span></span><br><span class="line">            ).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()  <span class="comment"># 调用主函数，开始生成缩略图</span></span><br></pre></td></tr></table></figure>

<h3 id="threading-Thread"><a href="#threading-Thread" class="headerlink" title="threading.Thread()"></a><code>threading.Thread()</code></h3><p> 是 Python 中用于创建线程的类，它允许我们在程序中创建新的线程来执行并发任务。下面是关于 <code>threading.Thread()</code> 的一些重要信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.Thread(target=<span class="literal">None</span>, args=(), kwargs=&#123;&#125;, daemon=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target</code>：可选参数，表示线程执行的目标函数。默认值为 <code>None</code>。如果提供了目标函数，那么在线程启动时会调用该目标函数。</li>
<li><code>args</code>：可选参数，表示传递给目标函数的位置参数。默认值为 <code>()</code>，即空元组。如果目标函数需要参数，可以将这些参数作为元组传递给 <code>args</code>。</li>
<li><code>kwargs</code>：可选参数，表示传递给目标函数的关键字参数。默认值为 <code>&#123;&#125;</code>，即空字典。如果目标函数需要关键字参数，可以将这些参数作为字典传递给 <code>kwargs</code>。</li>
<li><code>daemon</code>：可选参数，表示线程是否为守护线程。默认值为 <code>None</code>，表示采用主线程的守护线程属性。如果设为 <code>True</code>，则表示该线程为守护线程；如果设为 <code>False</code>，则表示该线程为非守护线程。</li>
</ul>
<p>多个线程竞争资源的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多线程程序如果没有竞争资源处理起来通常也比较简单</span></span><br><span class="line"><span class="string">当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱</span></span><br><span class="line"><span class="string">说明：临界资源就是被多个线程竞争的资源</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;银行账户&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.balance = <span class="number">0.0</span>  <span class="comment"># 初始化账户余额为 0.0</span></span><br><span class="line">        self.lock = threading.Lock()  <span class="comment"># 创建一个锁对象用于保护临界资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="comment"># 通过锁保护临界资源</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:  <span class="comment"># 使用 with 语句获取锁，确保锁的自动释放</span></span><br><span class="line">            new_balance = self.balance + money  <span class="comment"># 计算存款后的余额</span></span><br><span class="line">            time.sleep(<span class="number">0.001</span>)  <span class="comment"># 模拟存款操作需要的时间</span></span><br><span class="line">            self.balance = new_balance  <span class="comment"># 更新账户余额</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    account = Account()  <span class="comment"># 创建银行账户对象</span></span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">10</span>)  <span class="comment"># 创建最大线程数为 10 的线程池</span></span><br><span class="line">    futures = []  <span class="comment"># 存储线程的 future 对象</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 循环提交 100 个存款任务到线程池中</span></span><br><span class="line">        future = pool.submit(account.deposit, <span class="number">1</span>)  <span class="comment"># 提交存款任务给线程池执行，并获取 future 对象</span></span><br><span class="line">        futures.append(future)  <span class="comment"># 将 future 对象添加到列表中</span></span><br><span class="line">    <span class="comment"># 关闭线程池</span></span><br><span class="line">    pool.shutdown()  <span class="comment"># 关闭线程池，不再接受新的任务</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:  <span class="comment"># 遍历线程的 future 对象列表</span></span><br><span class="line">        future.result()  <span class="comment"># 获取每个存款任务的执行结果</span></span><br><span class="line">    <span class="built_in">print</span>(account.balance)  <span class="comment"># 打印最终账户余额</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()  <span class="comment"># 调用主函数开始执行程序</span></span><br></pre></td></tr></table></figure>

<p>这段代码演示了多线程环境下的银行账户存款操作。通过引入锁对象 <code>threading.Lock()</code> 来保护临界资源（即账户余额），避免多个线程同时修改账户余额而导致数据错乱。利用线程池 <code>concurrent.futures.ThreadPoolExecutor</code> 来管理线程，实现了多个存款任务的并发执行。</p>
<h3 id="concurrent-futures-ThreadPoolExecutor"><a href="#concurrent-futures-ThreadPoolExecutor" class="headerlink" title="concurrent.futures.ThreadPoolExecutor"></a><code>concurrent.futures.ThreadPoolExecutor</code></h3><p>是 Python 中用于管理线程池的高级线程管理器，它提供了一种简单而强大的方式来处理并发任务。以下是关于 <code>ThreadPoolExecutor</code> 的一些重要信息：</p>
<ul>
<li><p><strong>功能</strong>：<code>ThreadPoolExecutor</code> 允许在后台并发执行多个任务，并管理这些任务的线程池。它实现了一个线程池，可以管理多个线程，并在需要时创建新的线程，从而提高程序的并发性能。</p>
</li>
<li><p><strong>构造函数签名</strong>：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(max_workers=<span class="literal">None</span>, thread_name_prefix=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数说明</strong>：</p>
<ul>
<li><code>max_workers</code>：可选参数，表示线程池中允许存在的最大线程数。默认值为 <code>None</code>，表示根据系统的实际情况自动确定线程池的最大容量。</li>
<li><code>thread_name_prefix</code>：可选参数，表示线程名称的前缀。默认值为空字符串。</li>
</ul>
</li>
<li><p><strong>常用方法</strong>：</p>
<ul>
<li><code>submit(fn, *args, **kwargs)</code>：向线程池提交一个可调用对象以及其参数，返回一个 <code>concurrent.futures.Future</code> 对象，用于获取任务的执行结果。</li>
<li><code>map(func, *iterables, timeout=None, chunksize=1)</code>：类似于内置的 <code>map()</code> 函数，对可迭代对象中的元素依次应用函数，并返回结果迭代器。</li>
<li><code>shutdown(wait=True)</code>：关闭线程池，并等待所有线程任务执行完成。默认情况下会阻塞主线程，直到所有任务都执行完毕。</li>
</ul>
</li>
</ul>
<p>修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用<code>threading</code>模块的<code>Condition</code>来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）</span></span><br><span class="line"><span class="string">多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore）</span></span><br><span class="line"><span class="string">多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 导入必要的库</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义银行账户类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;银行账户&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, balance=<span class="number">0</span></span>):</span><br><span class="line">        <span class="comment"># 初始化账户余额</span></span><br><span class="line">        self.balance = balance</span><br><span class="line">        <span class="comment"># 创建一个可重入锁对象，并将其用于创建条件对象</span></span><br><span class="line">        lock = threading.RLock()</span><br><span class="line">        self.condition = threading.Condition(lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;取钱&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用条件对象进入临界区</span></span><br><span class="line">        <span class="keyword">with</span> self.condition:</span><br><span class="line">            <span class="comment"># 当需要取出的金额大于账户余额时，等待</span></span><br><span class="line">            <span class="keyword">while</span> money &gt; self.balance:</span><br><span class="line">                self.condition.wait()</span><br><span class="line">            <span class="comment"># 更新账户余额</span></span><br><span class="line">            new_balance = self.balance - money</span><br><span class="line">            sleep(<span class="number">0.001</span>)  <span class="comment"># 模拟取钱过程耗时</span></span><br><span class="line">            self.balance = new_balance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存钱&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用条件对象进入临界区</span></span><br><span class="line">        <span class="keyword">with</span> self.condition:</span><br><span class="line">            <span class="comment"># 更新账户余额</span></span><br><span class="line">            new_balance = self.balance + money</span><br><span class="line">            sleep(<span class="number">0.001</span>)  <span class="comment"># 模拟存钱过程耗时</span></span><br><span class="line">            self.balance = new_balance</span><br><span class="line">            <span class="comment"># 唤醒所有等待中的线程</span></span><br><span class="line">            self.condition.notify_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义存钱的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_money</span>(<span class="params">account</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 随机生成存入的金额</span></span><br><span class="line">        money = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 调用账户对象的存钱方法</span></span><br><span class="line">        account.deposit(money)</span><br><span class="line">        <span class="comment"># 打印当前线程的名称、存入的金额和账户余额</span></span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, </span><br><span class="line">              <span class="string">&#x27;:&#x27;</span>, money, <span class="string">&#x27;====&gt;&#x27;</span>, account.balance)</span><br><span class="line">        sleep(<span class="number">0.5</span>)  <span class="comment"># 等待一段时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义取钱的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_money</span>(<span class="params">account</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 随机生成取出的金额</span></span><br><span class="line">        money = randint(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line">        <span class="comment"># 调用账户对象的取钱方法</span></span><br><span class="line">        account.withdraw(money)</span><br><span class="line">        <span class="comment"># 打印当前线程的名称、取出的金额和账户余额</span></span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, </span><br><span class="line">              <span class="string">&#x27;:&#x27;</span>, money, <span class="string">&#x27;&lt;====&#x27;</span>, account.balance)</span><br><span class="line">        sleep(<span class="number">1</span>)  <span class="comment"># 等待一段时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建银行账户对象</span></span><br><span class="line">    account = Account()</span><br><span class="line">    <span class="comment"># 使用线程池来管理线程</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">15</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 启动5个存钱线程</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            pool.submit(add_money, account)</span><br><span class="line">        <span class="comment"># 启动10个取钱线程</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            pool.submit(sub_money, account)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>这段代码是一个简单的多线程模拟银行账户的存取款操作。使用了Python的<code>concurrent.futures</code>模块中的<code>ThreadPoolExecutor</code>来管理线程池，以及<code>threading</code>模块中的锁和条件对象来控制线程的并发访问。<code>Account</code>类表示银行账户，其中<code>withdraw</code>方法用于取钱，<code>deposit</code>方法用于存钱。<code>add_money</code>函数模拟存钱操作，<code>sub_money</code>函数模拟取钱操作。在<code>main</code>函数中创建了一个银行账户对象，然后启动了多个存钱和取钱线程来对该账户进行操作。</p>
<h3 id="Condition（条件对象）"><a href="#Condition（条件对象）" class="headerlink" title="Condition（条件对象）"></a><code>Condition</code>（条件对象）</h3><p>是Python中线程同步的一种机制，它允许线程在满足特定条件之前暂停执行，并在其他线程改变条件后被唤醒。<code>Condition</code>对象通常与锁（<code>Lock</code>或<code>RLock</code>）一起使用，以便在访问共享资源时保持线程安全。</p>
<p><code>Condition</code>对象提供了<code>wait()</code>、<code>notify()</code>和<code>notify_all()</code>等方法：</p>
<ul>
<li><code>wait(timeout=None)</code>: 使当前线程在调用<code>wait()</code>方法时释放锁，并进入等待状态，直到另一个线程调用<code>notify()</code>或<code>notify_all()</code>方法唤醒它，或者超时时间到达。</li>
<li><code>notify(n=1)</code>: 唤醒等待队列中的一个线程（默认是队列中的第一个），使其从<code>wait()</code>方法中返回。</li>
<li><code>notify_all()</code>: 唤醒等待队列中的所有线程，使它们从<code>wait()</code>方法中返回。</li>
</ul>
<p><code>Condition</code>对象通常用于管理多个线程之间的协作，例如在生产者-消费者模型中，生产者在生成数据后通知消费者进行消费，或者在多个线程需要等待某个共享资源可用时，通过条件对象来进行等待和通知。</p>
<h3 id="重点：多线程和多进程的比较。"><a href="#重点：多线程和多进程的比较。" class="headerlink" title="重点：多线程和多进程的比较。"></a><strong>重点</strong>：<strong>多线程和多进程的比较</strong>。</h3><blockquote>
<p>以下情况需要使用多线程：</p>
<ol>
<li>程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。</li>
<li>程序会花费大量时间在I&#x2F;O操作上，没有太多并行计算的需求且不需占用太多的内存。</li>
</ol>
<p>以下情况需要使用多进程：</p>
<ol>
<li>程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。</li>
<li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li>
<li>程序在内存使用方面没有任何限制且不强依赖于I&#x2F;O操作（如：读写文件、套接字等）。</li>
</ol>
</blockquote>
<p>- </p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>异步处理是一种编程模型，用于处理非阻塞的并发任务。在异步处理中，任务的执行不会按照传统的顺序依次进行，而是根据事件发生的顺序进行响应。这种模型能够提高程序的并发性能和资源利用率，特别适用于 I&#x2F;O 密集型任务</p>
<p>：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于<strong>执行时间和顺序的不确定</strong>，因此需要通过回调式编程或者<code>future</code>对象来获取任务执行的结果。Python 3通过<code>asyncio</code>模块和<code>await</code>和<code>async</code>关键字（在Python 3.7中正式被列为关键字）来支持异步处理。</p>
<p><code>asyncio</code> 是 Python 3.4 引入的一个标准库，用于编写异步代码，支持异步 I&#x2F;O 操作，例如网络通信、文件操作等。它提供了一种基于事件循环的模型，使得在单线程中能够处理并发的 I&#x2F;O 操作，从而提高程序的效率和性能。</p>
<p><code>await</code> 和 <code>async</code> 则是 Python 3.5 引入的新语法，用于定义协程（coroutine）。协程是一种轻量级的线程，可以在异步编程中用于处理并发任务。在 <code>asyncio</code> 中，协程是异步操作的基本单元，可以通过 <code>await</code> 来挂起当前协程的执行，等待异步操作完成，然后再继续执行下一步操作。</p>
<ul>
<li><code>async def function_name()</code> 定义一个异步函数，函数内部可以包含 <code>await</code> 表达式，用于等待异步操作的结果。</li>
<li><code>await expression</code> 用于等待一个异步表达式的执行结果，表达式可以是一个异步函数调用、一个异步迭代器的 <code>__anext__()</code> 方法，或者其他支持异步操作的对象。</li>
</ul>
<p>通过结合使用 <code>asyncio</code> 模块和 <code>await</code>、<code>async</code> 关键字，可以编写清晰、简洁、高效的异步代码，处理并发的 I&#x2F;O 操作，提高程序的性能和响应速度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">异步I/O - async / await</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 导入 asyncio 模块，用于实现异步编程</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个生成指定范围数字的生成器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num_generator</span>(<span class="params">m, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;指定范围的数字生成器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(m, n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个异步函数，用于过滤素数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">prime_filter</span>(<span class="params">m, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;素数过滤器&quot;&quot;&quot;</span></span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_generator(m, n):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断是否为素数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(i ** <span class="number">0.5</span> + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="comment"># 打印素数</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Prime =&gt;&#x27;</span>, i)</span><br><span class="line">            primes.append(i)</span><br><span class="line">        <span class="comment"># 异步等待一段时间</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(primes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个异步函数，用于计算数字的平方</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">square_mapper</span>(<span class="params">m, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;平方映射器&quot;&quot;&quot;</span></span><br><span class="line">    squares = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_generator(m, n):</span><br><span class="line">        <span class="comment"># 计算数字的平方并打印</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Square =&gt;&#x27;</span>, i * i)</span><br><span class="line">        squares.append(i * i)</span><br><span class="line">        <span class="comment"># 异步等待一段时间</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> squares</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取事件循环对象</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 创建两个异步任务，分别对应素数过滤和平方映射</span></span><br><span class="line">    future = asyncio.gather(prime_filter(<span class="number">2</span>, <span class="number">100</span>), square_mapper(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line">    <span class="comment"># 注册回调函数，在任务完成时打印结果</span></span><br><span class="line">    future.add_done_callback(<span class="keyword">lambda</span> x: <span class="built_in">print</span>(x.result()))</span><br><span class="line">    <span class="comment"># 运行事件循环，直到所有任务完成</span></span><br><span class="line">    loop.run_until_complete(future)</span><br><span class="line">    <span class="comment"># 关闭事件循环</span></span><br><span class="line">    loop.close()</span><br><span class="line"><span class="string">&quot;&quot;&quot;在这个主函数中，`future` 是一个 `asyncio.Future` 对象，它代表了一个异步任务的结果，或者说是一个未来会完成的操作的结果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">具体来说：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 在这个主函数中，通过 `asyncio.gather()` 函数创建了两个异步任务：`prime_filter(2, 100)` 和 `square_mapper(1, 100)`。`asyncio.gather()` 函数用于并行运行多个异步任务，并在所有任务完成后返回一个包含所有结果的 Future 对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- `future.add_done_callback(lambda x: print(x.result()))` 为 `future` 对象添加了一个回调函数，当异步任务完成时会调用该函数，并打印异步任务的结果。这里使用 `x.result()` 来获取异步任务的结果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 最后，通过 `loop.run_until_complete(future)` 运行了事件循环，直到所有任务完成。这会阻塞当前线程直到所有任务完成，并调用回调函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 最后，通过 `loop.close()` 关闭事件循环，释放资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">总的来说，`future` 在这里代表了两个异步任务的结果，通过回调函数和事件循环的运行来处理这些结果。&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：上面的代码使用<code>get_event_loop</code>函数获得系统默认的事件循环，通过<code>gather</code>函数可以获得一个<code>future</code>对象，<code>future</code>对象的<code>add_done_callback</code>可以添加执行完成时的回调函数，<code>loop</code>对象的<code>run_until_complete</code>方法可以等待通过<code>future</code>对象获得协程执行结果。</p>
<ol>
<li><strong>异步处理</strong>：通过使用 asyncio 模块和 async&#x2F;await 关键字，实现了异步处理的功能。素数过滤和计算数字平方的任务被定义为异步函数，可以并发执行而不会阻塞主线程。</li>
<li><strong>并发执行</strong>：主函数中创建了两个异步任务：prime_filter(2, 100) 和 square_mapper(1, 100)，它们分别负责对数字进行素数过滤和计算平方。这两个任务可以并发执行，不需要等待前一个任务完成才能执行后一个任务。</li>
<li><strong>事件循环</strong>：通过 asyncio.get_event_loop() 获取事件循环对象，并使用 loop.run_until_complete() 来运行事件循环，直到所有任务完成。事件循环负责调度和执行异步任务，并在任务完成时执行相应的回调函数。</li>
<li><strong>结果处理</strong>：使用 future.add_done_callback() 注册了一个回调函数，当所有任务完成时会打印任务的结果。这里使用了 x.result() 来获取任务的执行结果。</li>
</ol>
</blockquote>
<h3 id="事件循环对象（Event-Loop-Object）"><a href="#事件循环对象（Event-Loop-Object）" class="headerlink" title="事件循环对象（Event Loop Object）"></a>事件循环对象（Event Loop Object）</h3><p>是异步编程中的核心概念之一。它负责调度和执行异步任务，并处理任务的完成、挂起、唤醒等操作。在 Python 中，主要通过 asyncio 模块来创建和操作事件循环对象。</p>
<p>以下是关于事件循环对象的一些重要信息：</p>
<ol>
<li><p><strong>创建事件循环对象</strong>：可以使用 <code>asyncio.get_event_loop()</code> 函数获取当前线程的事件循环对象。如果当前线程没有事件循环对象，则会创建一个新的事件循环对象。通常在程序的主函数或入口处调用此函数。</p>
</li>
<li><p><strong>运行事件循环</strong>：一旦获取到事件循环对象，可以通过调用 <code>run_forever()</code> 或 <code>run_until_complete()</code> 方法来运行事件循环。<code>run_forever()</code> 方法会一直运行事件循环，直到调用 <code>stop()</code> 方法停止。而 <code>run_until_complete()</code> 方法会运行事件循环直到某个 Future 对象完成，或者直到超时。一般来说，在异步程序中，会在主函数或入口处使用 <code>run_until_complete()</code> 来运行事件循环，直到所有任务完成。</p>
</li>
<li><p><strong>关闭事件循环</strong>：一旦所有任务都完成了，需要关闭事件循环以释放资源。可以调用事件循环对象的 <code>close()</code> 方法来关闭事件循环。</p>
</li>
<li><p><strong>添加任务</strong>：在事件循环运行期间，可以通过 <code>create_task()</code> 或 <code>ensure_future()</code> 方法向事件循环中添加异步任务，使其被事件循环调度和执行。</p>
</li>
<li><p><strong>处理异常</strong>：事件循环对象还提供了处理异常的接口，可以通过 <code>set_exception_handler()</code> 方法设置异常处理器，对事件循环中的异常进行统一处理。</p>
</li>
</ol>
<p>总的来说，事件循环对象是异步编程中非常重要的一个概念，它负责协调异步任务的执行，确保它们能够以合适的方式被调度和执行。</p>
<p>Python中有一个名为<code>aiohttp</code>的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟<code>asyncio</code>模块一起工作，并提供了对<code>Future</code>对象的支持。Python 3.6中引入了<code>async</code>和<code>await</code>来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio  <span class="comment"># 导入 asyncio 模块，用于异步编程</span></span><br><span class="line"><span class="keyword">import</span> re  <span class="comment"># 导入 re 模块，用于正则表达式匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp  <span class="comment"># 导入 aiohttp 模块，用于进行异步的 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">PATTERN = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\&lt;title\&gt;(?P&lt;title&gt;.*)\&lt;\/title\&gt;&#x27;</span>)  <span class="comment"># 定义一个正则表达式模式，用于匹配 HTML 页面中的标题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_page</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="comment"># 异步函数，用于通过 aiohttp 发起 HTTP 请求并获取页面内容</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, ssl=<span class="literal">False</span>) <span class="keyword">as</span> resp:  <span class="comment"># 使用 aiohttp 客户端会话发起 GET 请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.text()  <span class="comment"># 返回页面的文本内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">show_title</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 异步函数，用于展示页面的标题</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># 创建 aiohttp 客户端会话</span></span><br><span class="line">        html = <span class="keyword">await</span> fetch_page(session, url)  <span class="comment"># 获取页面内容</span></span><br><span class="line">        <span class="built_in">print</span>(PATTERN.search(html).group(<span class="string">&#x27;title&#x27;</span>))  <span class="comment"># 通过正则表达式搜索页面中的标题并打印</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 主函数</span></span><br><span class="line">    urls = (<span class="string">&#x27;https://www.python.org/&#x27;</span>,  <span class="comment"># 要访问的网址列表</span></span><br><span class="line">            <span class="string">&#x27;https://git-scm.com/&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.jd.com/&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.taobao.com/&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.douban.com/&#x27;</span>)</span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># 获取事件循环对象</span></span><br><span class="line">    cos = [show_title(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]  <span class="comment"># 创建协程对象列表</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait(cos))  <span class="comment"># 运行事件循环，直到所有协程完成</span></span><br><span class="line">    loop.close()  <span class="comment"># 关闭事件循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()  <span class="comment"># 程序入口，执行主函数</span></span><br></pre></td></tr></table></figure>

<h3 id="重点：异步I-O与多进程的比较。"><a href="#重点：异步I-O与多进程的比较。" class="headerlink" title="重点：异步I&#x2F;O与多进程的比较。"></a><strong>重点</strong>：<strong>异步I&#x2F;O与多进程的比较</strong>。</h3><blockquote>
<p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，<code>asyncio</code>就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑<code>asyncio</code>，它很适合编写没有实时数据处理需求的Web应用服务器。</p>
</blockquote>
<p>Python还有很多用于处理并行任务的三方库，例如：<code>joblib</code>、<code>PyMP</code>等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p>
<p>要实现任务的异步化，可以使用名为<code>Celery</code>的三方库。<code>Celery</code>是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p>
<h2 id="Web前端概述"><a href="#Web前端概述" class="headerlink" title="Web前端概述"></a>Web前端概述</h2><p>HTML 是用来描述网页的一种语言，全称是 Hyper-Text Markup Language，即超文本标记语言。我们浏览网页时看到的文字、按钮、图片、视频等元素，它们都是通过 HTML 书写并通过浏览器来呈现的。</p>
<h3 id="使用JavaScript控制行为"><a href="#使用JavaScript控制行为" class="headerlink" title="使用JavaScript控制行为"></a>使用JavaScript控制行为</h3><h4 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h4><ul>
<li>语句和注释</li>
<li>变量和数据类型<ul>
<li>声明和赋值</li>
<li>简单数据类型和复杂数据类型</li>
<li>变量的命名规则</li>
</ul>
</li>
<li>表达式和运算符<ul>
<li>赋值运算符</li>
<li>算术运算符</li>
<li>比较运算符</li>
<li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li>
</ul>
</li>
<li>分支结构<ul>
<li><code>if...else...</code></li>
<li><code>switch...cas...default...</code></li>
</ul>
</li>
<li>循环结构<ul>
<li><code>for</code>循环</li>
<li><code>while</code>循环</li>
<li><code>do...while</code>循环</li>
</ul>
</li>
<li>数组<ul>
<li>创建数组</li>
<li>操作数组中的元素</li>
</ul>
</li>
<li>函数<ul>
<li>声明函数</li>
<li>调用函数</li>
<li>参数和返回值</li>
<li>匿名函数</li>
<li>立即调用函数</li>
</ul>
</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li>对象的概念</li>
<li>创建对象的字面量语法</li>
<li>访问成员运算符</li>
<li>创建对象的构造函数语法<ul>
<li><code>this</code>关键字</li>
</ul>
</li>
<li>添加和删除属性<ul>
<li><code>delete</code>关键字</li>
</ul>
</li>
<li>标准对象<ul>
<li><code>Number</code> &#x2F; <code>String</code> &#x2F; <code>Boolean</code> &#x2F; <code>Symbol</code> &#x2F; <code>Array</code> &#x2F; <code>Function</code></li>
<li><code>Date</code> &#x2F; <code>Error</code> &#x2F; <code>Math</code> &#x2F; <code>RegExp</code> &#x2F; <code>Object</code> &#x2F; <code>Map</code> &#x2F; <code>Set</code></li>
<li><code>JSON</code> &#x2F; <code>Promise</code> &#x2F; <code>Generator</code> &#x2F; <code>Reflect</code> &#x2F; <code>Proxy</code></li>
</ul>
</li>
</ul>
<h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><ul>
<li><p><code>window</code>对象的属性和方法</p>
</li>
<li><pre><code>  history
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	对象</span><br><span class="line"></span><br><span class="line">	- `forward()` / `back()` / `go()`</span><br><span class="line"></span><br><span class="line">- `location`对象</span><br><span class="line"></span><br><span class="line">- `navigator`对象</span><br><span class="line"></span><br><span class="line">- `screen`对象</span><br><span class="line"></span><br><span class="line">#### DOM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- DOM树</span><br><span class="line">- 访问元素</span><br><span class="line">	- `getElementById()` / `querySelector()`</span><br><span class="line">	- `getElementsByClassName()` / `getElementsByTagName()` / `querySelectorAll()`</span><br><span class="line">	- `parentNode` / `previousSibling` / `nextSibling` / `children` / `firstChild` / `lastChild`</span><br><span class="line">- 操作元素</span><br><span class="line">	- `nodeValue`</span><br><span class="line">	- `innerHTML` / `textContent` / `createElement()` / `createTextNode()` / `appendChild()` / `insertBefore()` / `removeChild()`</span><br><span class="line">	- `className` / `id` / `hasAttribute()` / `getAttribute()` / `setAttribute()` / `removeAttribute()`</span><br><span class="line">- 事件处理</span><br><span class="line">	- 事件类型</span><br><span class="line">		- UI事件：`load` / `unload` / `error` / `resize` / `scroll`</span><br><span class="line">		- 键盘事件：`keydown` / `keyup` / `keypress`</span><br><span class="line">		- 鼠标事件：`click` / `dbclick` / `mousedown` / `mouseup` / `mousemove` / `mouseover` / `mouseout`</span><br><span class="line">		- 焦点事件：`focus` / `blur`</span><br><span class="line">		- 表单事件：`input` / `change` / `submit` / `reset` / `cut` / `copy` / `paste` / `select`</span><br><span class="line">	- 事件绑定</span><br><span class="line">		- HTML事件处理程序（不推荐使用，因为要做到标签与代码分离）</span><br><span class="line">		- 传统的DOM事件处理程序（只能附加一个回调函数）</span><br><span class="line">		- 事件监听器（旧的浏览器中不被支持）</span><br><span class="line">	- 事件流：事件捕获 / 事件冒泡</span><br><span class="line">	- 事件对象（低版本IE中的window.event）</span><br><span class="line">		- `target`（有些浏览器使用srcElement）</span><br><span class="line">		- `type`</span><br><span class="line">		- `cancelable`</span><br><span class="line">		- `preventDefault()`</span><br><span class="line">		- `stopPropagation()`（低版本IE中的cancelBubble）</span><br><span class="line">	- 鼠标事件 - 事件发生的位置</span><br><span class="line">		- 屏幕位置：`screenX`和`screenY`</span><br><span class="line">		- 页面位置：`pageX`和`pageY`</span><br><span class="line">		- 客户端位置：`clientX`和`clientY`</span><br><span class="line">	- 键盘事件 - 哪个键被按下了</span><br><span class="line">		- `keyCode`属性（有些浏览器使用`which`）</span><br><span class="line">		- `String.fromCharCode(event.keyCode)`</span><br><span class="line">	- HTML5事件</span><br><span class="line">		- `DOMContentLoaded`</span><br><span class="line">		- `hashchange`</span><br><span class="line">		- `beforeunload`</span><br><span class="line"></span><br><span class="line">#### JavaScript API</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 客户端存储 - `localStorage`和`sessionStorage`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  localStorage.colorSetting = &#39;#a4509b&#39;;
  localStorage[&#39;colorSetting&#39;] = &#39;#a4509b&#39;;
  localStorage.setItem(&#39;colorSetting&#39;, &#39;#a4509b&#39;);
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">- 获取位置信息 - `geolocation`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  navigator.geolocation.getCurrentPosition(function(pos) &#123; 		  
      console.log(pos.coords.latitude)
      console.log(pos.coords.longitude)
  &#125;)
</code></pre>
</li>
<li><p>从服务器获取数据 - Fetch API</p>
</li>
<li><p>绘制图形 - <code>&lt;canvas&gt;</code>的API</p>
</li>
<li><p>音视频 - <code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>的API</p>
</li>
</ul>
<h3 id="使用jQuery"><a href="#使用jQuery" class="headerlink" title="使用jQuery"></a>使用jQuery</h3><h4 id="jQuery概述"><a href="#jQuery概述" class="headerlink" title="jQuery概述"></a>jQuery概述</h4><ol>
<li>Write Less Do More（用更少的代码来完成更多的工作）</li>
<li>使用CSS选择器来查找元素（更简单更方便）</li>
<li>使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法）</li>
</ol>
<h3 id="使用Ajax"><a href="#使用Ajax" class="headerlink" title="使用Ajax"></a>使用Ajax</h3><p>Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<ul>
<li>原生的Ajax</li>
<li>基于jQuery的Ajax<ul>
<li>加载内容</li>
<li>提交表单</li>
</ul>
</li>
</ul>
<h2 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h2><h3 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h3><p>Linux是一个通用操作系统。一个操作系统要负责<strong>任务调度、内存分配、处理外围设备I&#x2F;O</strong>等操作。操作系统通常由内核（运行其他程序，管理像磁盘、打印机等硬件设备的核心程序）和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。</p>
<p>Linux内核是芬兰人Linus Torvalds开发的，于1991年9月发布。而Linux操作系统作为Internet时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意自由和免费并不是同一个概念，想了解二者的差别可以<a target="_blank" rel="noopener" href="https://www.debian.org/intro/free">点击这里</a>）。</p>
<h3 id="Linux系统优点"><a href="#Linux系统优点" class="headerlink" title="Linux系统优点"></a>Linux系统优点</h3><ol>
<li>通用操作系统，不跟特定的硬件绑定。</li>
<li>用C语言编写，可移植性强，有内核编程接口。</li>
<li>支持多用户和多任务，支持安全的分层文件系统。</li>
<li>大量的实用程序，完善的网络功能以及强大的支持文档。</li>
<li>可靠的安全性和良好的稳定性，对开发者更友好。</li>
</ol>
<h2 id="关系型数据库概述"><a href="#关系型数据库概述" class="headerlink" title="关系型数据库概述"></a>关系型数据库概述</h2><ol>
<li><p><strong>数据持久化</strong> - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。</p>
</li>
<li><p>数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL 数据库、NewSQL 数据库。</p>
<blockquote>
<p>1970年，IBM的研究员E.F.Codd在<em>Communication of the ACM</em>上发表了名为<em>A Relational Model of Data for Large Shared Data Banks</em>的论文，提出了<strong>关系模型</strong>的概念，奠定了关系模型的理论基础。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。</p>
</blockquote>
</li>
<li><p>关系数据库特点。</p>
<ul>
<li>理论基础：<strong>关系代数</strong>（关系运算、集合论、一阶谓词逻辑）。</li>
<li>具体表象：用<strong>二维表</strong>（有行和列）组织数据。</li>
<li>编程语言：<strong>结构化查询语言</strong>（SQL）。</li>
</ul>
</li>
</ol>
<h2 id="Django快速上手"><a href="#Django快速上手" class="headerlink" title="Django快速上手"></a>Django快速上手</h2><p>Web开发的早期阶段，开发者需要手动编写每个页面，例如一个新闻门户网站，每天都要修改它的HTML页面，随着网站规模和体量的增大，这种做法一定是非常糟糕的。为了解决这个问题，开发人员想到了用程序来为Web服务器生成动态内容，也就是说网页中的动态内容不再通过手动编写而是通过程序自动生成。最早的时候，这项技术被称为CGI（公共网关接口），当然随着时间的推移，CGI暴露出的问题也越来越多，例如大量重复的样板代码，总体性能较为低下等。在时代呼唤新英雄的背景下，PHP、ASP、JSP这类Web应用开发技术在上世纪90年代中后期如雨后春笋般涌现。通常我们说的Web应用是指<strong>通过浏览器来访问网络资源</strong>的应用程序，因为浏览器的普及性以及易用性，Web应用使用起来方便简单，免除了安装和更新应用程序带来的麻烦；站在开发者的角度，也不用关心用户使用什么样的操作系统，甚至不用区分是PC端还是移动端。</p>
<h3 id="Web应用机制和术语"><a href="#Web应用机制和术语" class="headerlink" title="Web应用机制和术语"></a>Web应用机制和术语</h3><p>下图向我们展示了Web应用的工作流程，其中涉及到的术语如下表所示。</p>
<p>![截屏2024-03-14 14.59.32](..&#x2F;..&#x2F;..&#x2F;Desktop&#x2F;截屏2024-03-14 14.59.32.png)</p>
<blockquote>
<p>说明：相信有经验的读者会发现，这张图中其实还少了很多东西，例如反向代理服务器、数据库服务器、防火墙等，而且图中的每个节点在实际项目部署时可能是一组节点组成的集群。当然，如果你对这些没有什么概念也不要紧，继续下去就行了，后面会给大家一一讲解的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL&#x2F;URI</strong></td>
<td>统一资源定位符&#x2F;统一资源标识符，网络资源的唯一标识</td>
</tr>
<tr>
<td><strong>域名</strong></td>
<td>与Web服务器地址对应的一个易于记忆的字符串名字</td>
</tr>
<tr>
<td><strong>DNS</strong></td>
<td>域名解析服务，可以将域名转换成对应的IP地址</td>
</tr>
<tr>
<td><strong>IP地址</strong></td>
<td>网络上的主机的身份标识，通过IP地址可以区分不同的主机</td>
</tr>
<tr>
<td><strong>HTTP</strong></td>
<td>超文本传输协议，构建在TCP之上的应用级协议，万维网数据通信的基础</td>
</tr>
<tr>
<td><strong>反向代理</strong></td>
<td>代理客户端向服务器发出请求，然后将服务器返回的资源返回给客户端</td>
</tr>
<tr>
<td><strong>Web服务器</strong></td>
<td>接受HTTP请求，然后返回HTML文件、纯文本文件、图像等资源给请求者</td>
</tr>
<tr>
<td><strong>Nginx</strong></td>
<td>高性能的Web服务器，也可以用作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理</a>，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a> 和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP%E7%BC%93%E5%AD%98">HTTP缓存</a></td>
</tr>
</tbody></table>
<h3 id="Django概述"><a href="#Django概述" class="headerlink" title="Django概述"></a>Django概述</h3><p>Python的Web框架有上百个，比它的关键字还要多。所谓Web框架，就是用于开发Web服务器端应用的基础设施，说得通俗一点就是一系列封装好的模块和工具。事实上，即便没有Web框架，我们仍然可以通过socket或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3">CGI</a>来开发Web服务器端应用，但是这样做的成本和代价在商业项目中通常是不能接受的。通过Web框架，我们可以化繁为简，降低创建、更新、扩展应用程序的工作量。刚才我们说到Python有上百个Web框架，这些框架包括Django、Flask、Tornado、Sanic、Pyramid、Bottle、Web2py、web.py等。</p>
<p>在上述Python的Web框架中，Django无疑是最有代表性的重量级选手，开发者可以基于Django快速的开发可靠的Web应用程序，因为它减少了Web开发中不必要的开销，对常用的设计和开发模式进行了封装，并对MVC架构提供了支持（Django中称之为MTV架构）。MVC是软件系统开发领域中一种放之四海而皆准的架构，它将系统中的组件分为<strong>模型（Model）、视图（View）和控制器（Controller）</strong>三个部分并借此实现模型（数据）和视图（显示）的解耦合。由于模型和视图进行了分离，所以需要一个中间人将解耦合的模型和视图联系起来，扮演这个角色的就是控制器。稍具规模的软件系统都会使用MVC架构（或者是从MVC演进出的其他架构），Django项目中我们称之为MTV，MTV中的M跟MVC中的M没有区别，就是代表数据的模型，T代表了网页模板（显示数据的视图），而V代表了视图函数，在Django框架中，视图函数和Django框架本身一起扮演了MVC中C的角色。</p>
<p>Django框架诞生于2003年，它是一个在真正的应用中成长起来的项目，由劳伦斯出版集团旗下在线新闻网站的内容管理系统（CMS）研发团队（主要是Adrian Holovaty和Simon Willison）开发，以比利时的吉普赛爵士吉他手Django Reinhardt来命名。Django框架在2005年夏天作为开源框架发布，使用Django框架能用很短的时间构建出功能完备的网站，因为它代替程序员完成了那些重复乏味的劳动，剩下真正有意义的核心业务给程序员来开发，这一点就是对DRY（Don’t Repeat Yourself）理念的最好践行。许多成功的网站和应用都是基于Python语言进行开发的，国内比较有代表性的网站包括：知乎、豆瓣网、果壳网、搜狐闪电邮箱、101围棋网、海报时尚网、背书吧、堆糖、手机搜狐网、咕咚、爱福窝、果库等，其中不乏使用了Django框架的产品。</p>
<h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><h4 id="Django模型最佳实践"><a href="#Django模型最佳实践" class="headerlink" title="Django模型最佳实践"></a>Django模型最佳实践</h4><ol>
<li>正确的为模型和关系字段命名。</li>
<li>设置适当的<code>related_name</code>属性。</li>
<li>用<code>OneToOneField</code>代替<code>ForeignKeyField(unique=True)</code>。</li>
<li>通过“迁移操作”（migrate）来添加模型。</li>
<li>用NoSQL来应对需要降低范式级别的场景。</li>
<li>如果布尔类型可以为空要使用<code>NullBooleanField</code>。</li>
<li>在模型中放置业务逻辑。</li>
<li>用<code>&lt;ModelName&gt;.DoesNotExists</code>取代<code>ObjectDoesNotExists</code>。</li>
<li>在数据库中不要出现无效数据。</li>
<li>不要对<code>QuerySet</code>调用<code>len()</code>函数。</li>
<li>将<code>QuerySet</code>的<code>exists()</code>方法的返回值用于<code>if</code>条件。</li>
<li>用<code>DecimalField</code>来存储货币相关数据而不是<code>FloatField</code>。</li>
<li>定义<code>__str__</code>方法。</li>
<li>不要将数据文件放在同一个目录中。</li>
</ol>
<blockquote>
<p><strong>说明</strong>：以上内容来自于STEELKIWI网站的<a target="_blank" rel="noopener" href="https://steelkiwi.com/blog/best-practices-working-django-models-python/"><em>Best Practice working with Django models in Python</em></a>，有兴趣的小伙伴可以阅读原文。</p>
</blockquote>
<h4 id="模型定义参考"><a href="#模型定义参考" class="headerlink" title="模型定义参考"></a>模型定义参考</h4><h5 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h5><p>对字段名称的限制</p>
<ul>
<li>字段名不能是Python的保留字，否则会导致语法错误</li>
<li>字段名不能有多个连续下划线，否则影响ORM查询操作</li>
</ul>
<p>Django模型字段类</p>
<h3 id="Ajax概述"><a href="#Ajax概述" class="headerlink" title="Ajax概述"></a>Ajax概述</h3><p>接下来就可以实现“好评”和“差评”的功能了，很明显如果能够在不刷新页面的情况下实现这两个功能会带来更好的用户体验，因此我们考虑使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/AJAX">Ajax</a>技术来实现“好评”和“差评”。Ajax是Asynchronous Javascript And XML的缩写 , 简单的说，使用Ajax技术可以在<strong>不重新加载整个页面的情况下对页面进行局部刷新</strong>。</p>
<p>对于传统的Web应用，每次页面上需要加载新的内容都需要重新请求服务器并刷新整个页面，如果服务器短时间内无法给予响应或者网络状况并不理想，那么可能会造成浏览器长时间的空白并使得用户处于等待状态，在这个期间用户什么都做不了，如下图所示。很显然，这样的Web应用并不能带来很好的用户体验。</p>
<p>对于使用Ajax技术的Web应用，浏览器可以向服务器发起异步请求来获取数据。异步请求不会中断用户体验，当服务器返回了新的数据，我们可以通过JavaScript代码进行DOM操作来实现对页面的局部刷新，这样就相当于在不刷新整个页面的情况下更新了页面的内容，如下图所示。</p>
<p>在使用Ajax技术时，浏览器跟服务器通常会交换XML或JSON格式的数据，XML是以前使用得非常多的一种数据格式，近年来几乎已经完全被JSON取代，下面是两种数据格式的对比。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yjy1380.github.io/1989/06/05/python%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cltlkfe7u0000f5uq65pk9hm4" data-title="Python编程惯例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PEP8/" rel="tag">PEP8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEP8/" rel="tag">PEP8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/PEP8/" style="font-size: 10px;">PEP8</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/1989/06/">June 1989</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/1989/06/05/python%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">Python编程惯例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Junyi Yang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>